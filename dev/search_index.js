var documenterSearchIndex = {"docs":
[{"location":"extending/#Extending-Polynomials","page":"Extending","title":"Extending Polynomials","text":"","category":"section"},{"location":"extending/","page":"Extending","title":"Extending","text":"The AbstractPolynomial type was made to be extended via a rich interface.","category":"page"},{"location":"extending/","page":"Extending","title":"Extending","text":"AbstractPolynomial","category":"page"},{"location":"extending/#Polynomials.AbstractPolynomial","page":"Extending","title":"Polynomials.AbstractPolynomial","text":"AbstractPolynomial{T,X}\n\nAn abstract type for various polynomials.\n\nA polynomial type holds an indeterminate X; coefficients of type T, stored in some container type; and an implicit basis, such as the standard basis.\n\nProperties\n\ncoeffs - The coefficients of the polynomial\n\nThe type T\n\nT need not be T <: Number, at the moment it is not restricted\n\nSome Ts will not be successful\n\nscalar mult: c::Number * p::Polynomial should be defined\nscalar mult: c::T * p::Polynomial{T} An  ambiguity when T <: AbstractPolynomial\nscalar mult: p::Polynomial{T} * c::T need not commute\nadd/sub: p::Polynomial{T} + q::Polynomial{T} should be defined\nsub: p -p sometimes needs zero{T} defined\npoly mult: p::Polynomial{T} * q::Polynomial{T} Needs \"T * T\" defined (e.g. Base.promote_op(*, Vector{Int}, Vector{Int})) needs to be something.)\npoly powers: p::Polynomial{T}^2 needs \"T^2\" defined\nimplicit promotion: p::Polynomial{T} + c::Number  needs convert(T, c) defined\nimplicit promotion: p::Polynomial{T} + c::T  ambiguity if T <: AbstractPolynomial\nevaluation: p::Polynomial{T}(s::Number)\nevaluation p::Polynomial{T}(c::T)   needs T*T defined\nevaluation of a 0 polynomial requires zero(T) to be defined.\nderivatives: derivative(p::Polynomial{T})\nintegrals: integrate(p::Polynomial{T})\n\n\n\n\n\n","category":"type"},{"location":"extending/","page":"Extending","title":"Extending","text":"A polynomial's  coefficients  are  relative to some basis. The Polynomial type relates coefficients  [a0, a1,  ..., an], say,  to the  polynomial  a0 +  a1*x + a2*x^  + ... +  an*x^n,  through the standard  basis  1,  x,  x^2, ..., x^n.  New polynomial  types typically represent the polynomial through a different  basis. For example,  CheyshevT uses a basis  T_0=1, T_1=x,  T_2=2x^2-1,  ...,  T_n  =  2xT_{n-1} - T_{n-2}.  For this type  the  coefficients  [a0,a1,...,an] are associated with  the polynomial  a0*T0  + a1*T_1 +  ...  +  an*T_n.","category":"page"},{"location":"extending/","page":"Extending","title":"Extending","text":"To implement a new polynomial type, P, the following methods should be implemented.","category":"page"},{"location":"extending/","page":"Extending","title":"Extending","text":"note: Note\nPromotion rules will always coerce towards the Polynomial type, so not all methods have to be implemented if you provide a conversion function.","category":"page"},{"location":"extending/","page":"Extending","title":"Extending","text":"As always, if the default implementation does not work or there are more efficient ways of implementing, feel free to overwrite functions from common.jl for your type.","category":"page"},{"location":"extending/","page":"Extending","title":"Extending","text":"Function Required Notes\nConstructor x \nType function ((::P)(x)) x \nconvert(::Polynomial, ...)  Not required, but the library is built off the Polynomial type, so all operations are guaranteed to work with it. Also consider writing the inverse conversion method.\nPolynomials.evalpoly(x, p::P) to evaluate the polynomial at x (Base.evalpoly okay post v\"1.4.0\") \nPolynomials.domain x Should return a Polynomials.Interval instance\nvander  Required for fit\ncompanion  Required for roots\n*(::P, ::P)  Multiplication of polynomials\ndivrem  Required for gcd\none  Convenience to find constant in new basis\nvariable  Convenience to find monomial x in new  basis","category":"page"},{"location":"extending/","page":"Extending","title":"Extending","text":"Check out both the Polynomial and ChebyshevT for examples of this interface being extended.","category":"page"},{"location":"extending/#Example","page":"Extending","title":"Example","text":"","category":"section"},{"location":"extending/","page":"Extending","title":"Extending","text":"The following shows a minimal example where the polynomial aliases the vector defining the coefficients. The constructor ensures that there are no trailing zeros. The @register call ensures a common interface. This example subtypes StandardBasisPolynomial, not AbstractPolynomial, and consequently inherits the methods above that otherwise would have been required. For other bases, more methods may be necessary to define (again, refer to ChebyshevT for an example).","category":"page"},{"location":"extending/","page":"Extending","title":"Extending","text":"julia> using Polynomials\n\njulia> struct AliasPolynomial{T <: Number, X} <: Polynomials.StandardBasisPolynomial{T, X}\n                  coeffs::Vector{T}\n                  function AliasPolynomial{T, X}(coeffs::Vector{S}) where {T, X, S}\n                      p = new{T,X}(coeffs)\n                      chop!(p)\n                  end\n              end\n\njulia> Polynomials.@register AliasPolynomial","category":"page"},{"location":"extending/","page":"Extending","title":"Extending","text":"To see this new polynomial type in action, we have:","category":"page"},{"location":"extending/","page":"Extending","title":"Extending","text":"julia> xs = [1,2,3,4];\n\njulia> p = AliasPolynomial(xs)\nAliasPolynomial(1 + 2*x + 3*x^2 + 4*x^3)\n\njulia> q = AliasPolynomial(1.0, :y)\nAliasPolynomial(1.0)\n\njulia> p + q\nAliasPolynomial(2.0 + 2.0*x + 3.0*x^2 + 4.0*x^3)\n\njulia> p * p\nAliasPolynomial(1 + 4*x + 10*x^2 + 20*x^3 + 25*x^4 + 24*x^5 + 16*x^6)\n\njulia> (derivative ∘ integrate)(p) == p\ntrue\n\njulia> p(3)\n142","category":"page"},{"location":"extending/","page":"Extending","title":"Extending","text":"For the Polynomial type, the default on operations is to copy the array. For this type, it might seem reasonable – to avoid allocations – to update the coefficients in place for scalar addition and scalar multiplication.","category":"page"},{"location":"extending/","page":"Extending","title":"Extending","text":"Scalar addition, p+c, defaults to p + c*one(p), or polynomial addition, which is not inplace without addition work. As such, we create a new method and an infix operator","category":"page"},{"location":"extending/","page":"Extending","title":"Extending","text":"julia> function scalar_add!(p::AliasPolynomial{T}, c::T) where {T}\n           p.coeffs[1] += c\n           p\n       end;\n\njulia> p::AliasPolynomial ⊕ c::Number = scalar_add!(p,c);\n","category":"page"},{"location":"extending/","page":"Extending","title":"Extending","text":"Then we have:","category":"page"},{"location":"extending/","page":"Extending","title":"Extending","text":"julia> p\nAliasPolynomial(1 + 2*x + 3*x^2 + 4*x^3)\n\njulia> p ⊕ 2\nAliasPolynomial(3 + 2*x + 3*x^2 + 4*x^3)\n\njulia> p\nAliasPolynomial(3 + 2*x + 3*x^2 + 4*x^3)","category":"page"},{"location":"extending/","page":"Extending","title":"Extending","text":"The viewpoint that a polynomial represents a vector of coefficients  leads to an expectation that vector operations should match when possible. Scalar multiplication is a vector operation, so it seems reasonable to override the broadcast machinery to implement an in place operation (e.g. p .*= 2). By default, the polynomial types are not broadcastable over their coefficients. We would need to make a change there and modify the copyto! function:","category":"page"},{"location":"extending/","page":"Extending","title":"Extending","text":"julia> Base.broadcastable(p::AliasPolynomial) = p.coeffs;\n\n\njulia> Base.ndims(::Type{<:AliasPolynomial}) = 1\n\n\njulia> Base.copyto!(p::AliasPolynomial, x) = (copyto!(p.coeffs, x); chop!(p));\n","category":"page"},{"location":"extending/","page":"Extending","title":"Extending","text":"The last chop! call would ensure that there are no trailing zeros in the coefficient vector after multiplication, as multiplication by 0 is possible.","category":"page"},{"location":"extending/","page":"Extending","title":"Extending","text":"Then we might have:","category":"page"},{"location":"extending/","page":"Extending","title":"Extending","text":"julia> p\nAliasPolynomial(3 + 2*x + 3*x^2 + 4*x^3)\n\njulia> p .*= 2\nAliasPolynomial(6 + 4*x + 6*x^2 + 8*x^3)\n\njulia> p\nAliasPolynomial(6 + 4*x + 6*x^2 + 8*x^3)\n\njulia> p ./= 2\nAliasPolynomial(3 + 2*x + 3*x^2 + 4*x^3)","category":"page"},{"location":"extending/","page":"Extending","title":"Extending","text":"Trying to divide again would throw an error, as the result would not fit with the integer type of p.","category":"page"},{"location":"extending/","page":"Extending","title":"Extending","text":"Now p is treated as the vector p.coeffs, as regards broadcasting, so some things may be surprising, for example this expression returns a vector, not a polynomial:","category":"page"},{"location":"extending/","page":"Extending","title":"Extending","text":"julia> p .+ 2\n4-element Vector{Int64}:\n 5\n 4\n 5\n 6","category":"page"},{"location":"extending/","page":"Extending","title":"Extending","text":"The unexported Polynomials.PnPolynomial type implements much of this.","category":"page"},{"location":"polynomials/polynomial/#Polynomial","page":"Polynomial","title":"Polynomial","text":"","category":"section"},{"location":"polynomials/polynomial/","page":"Polynomial","title":"Polynomial","text":"Polynomial types using the standard basis.","category":"page"},{"location":"polynomials/polynomial/","page":"Polynomial","title":"Polynomial","text":"DocTestSetup = quote\n  using Polynomials\nend","category":"page"},{"location":"polynomials/polynomial/#Polynomial-2","page":"Polynomial","title":"Polynomial","text":"","category":"section"},{"location":"polynomials/polynomial/","page":"Polynomial","title":"Polynomial","text":"Polynomial","category":"page"},{"location":"polynomials/polynomial/#Polynomials.Polynomial","page":"Polynomial","title":"Polynomials.Polynomial","text":"Polynomial{T, X}(coeffs::AbstractVector{T}, [var = :x])\n\nConstruct a polynomial from its coefficients coeffs, lowest order first, optionally in terms of the given variable var which may be a character, symbol, or a string.\n\nIf p = a_n x^n + ldots + a_2 x^2 + a_1 x + a_0, we construct this through Polynomial([a_0, a_1, ..., a_n]).\n\nThe usual arithmetic operators are overloaded to work with polynomials as well as with combinations of polynomials and scalars. However, operations involving two polynomials of different variables causes an error except those involving a constant polynomial.\n\nnote: Note\nPolynomial is not axis-aware, and it treats coeffs simply as a list of coefficients with the first index always corresponding to the constant term. In order to use the axis of coeffs as exponents, consider using a LaurentPolynomial or possibly a SparsePolynomial.\n\nExamples\n\njulia> using Polynomials\n\njulia> Polynomial([1, 0, 3, 4])\nPolynomial(1 + 3*x^2 + 4*x^3)\n\njulia> Polynomial([1, 2, 3], :s)\nPolynomial(1 + 2*s + 3*s^2)\n\njulia> one(Polynomial)\nPolynomial(1.0)\n\n\n\n\n\n","category":"type"},{"location":"polynomials/polynomial/#Immutable-Polynomial","page":"Polynomial","title":"Immutable Polynomial","text":"","category":"section"},{"location":"polynomials/polynomial/","page":"Polynomial","title":"Polynomial","text":"ImmutablePolynomial","category":"page"},{"location":"polynomials/polynomial/#Polynomials.ImmutablePolynomial","page":"Polynomial","title":"Polynomials.ImmutablePolynomial","text":"ImmutablePolynomial{T, X, N}(coeffs::AbstractVector{T})\n\nConstruct an immutable (static) polynomial from its coefficients a₀, a₁, …, aₙ, lowest order first, optionally in terms of the given variable x where x can be a character, symbol, or string.\n\nIf p = a_n x^n + ldots + a_2 x^2 + a_1 x + a_0, we construct this through ImmutablePolynomial((a_0, a_1, ..., a_n)) (assuming a_n ≠ 0). As well, a vector or number can be used for construction.\n\nThe usual arithmetic operators are overloaded to work with polynomials as well as with combinations of polynomials and scalars. However, operations involving two non-constant polynomials of different variables causes an error. Unlike other polynomials, setindex! is not defined for ImmutablePolynomials.\n\nAs the degree of the polynomial (+1) is a compile-time constant, several performance improvements are possible. For example, immutable polynomials can take advantage of faster polynomial evaluation provided by evalpoly from Julia 1.4; similar methods are also used for addition and multiplication.\n\nHowever, as the degree is included in the type, promotion between immutable polynomials can not promote to a common type. As such, they are precluded from use in rational functions.\n\nnote: Note\nImmutablePolynomial is not axis-aware, and it treats coeffs simply as a list of coefficients with the first index always corresponding to the constant term.\n\nExamples\n\njulia> using  Polynomials\n\njulia> ImmutablePolynomial((1, 0, 3, 4))\nImmutablePolynomial(1 + 3*x^2 + 4*x^3)\n\njulia> ImmutablePolynomial((1, 2, 3), :s)\nImmutablePolynomial(1 + 2*s + 3*s^2)\n\njulia> one(ImmutablePolynomial)\nImmutablePolynomial(1.0)\n\nnote: Note\nThis was modeled after StaticUnivariatePolynomials by @tkoolen.\n\n\n\n\n\n","category":"type"},{"location":"polynomials/polynomial/#Sparse-Polynomial","page":"Polynomial","title":"Sparse Polynomial","text":"","category":"section"},{"location":"polynomials/polynomial/","page":"Polynomial","title":"Polynomial","text":"SparsePolynomial","category":"page"},{"location":"polynomials/polynomial/#Polynomials.SparsePolynomial","page":"Polynomial","title":"Polynomials.SparsePolynomial","text":"SparsePolynomial{T, X}(coeffs::Dict, [var = :x])\n\nPolynomials in the standard basis backed by a dictionary holding the non-zero coefficients. For polynomials of high degree, this might be advantageous.\n\nExamples:\n\njulia> using Polynomials\n\njulia> P  = SparsePolynomial\nSparsePolynomial\n\njulia> p, q = P([1,2,3]), P([4,3,2,1])\n(SparsePolynomial(1 + 2*x + 3*x^2), SparsePolynomial(4 + 3*x + 2*x^2 + x^3))\n\njulia> p + q\nSparsePolynomial(5 + 5*x + 5*x^2 + x^3)\n\njulia> p * q\nSparsePolynomial(4 + 11*x + 20*x^2 + 14*x^3 + 8*x^4 + 3*x^5)\n\njulia> p + 1\nSparsePolynomial(2 + 2*x + 3*x^2)\n\njulia> q * 2\nSparsePolynomial(8 + 6*x + 4*x^2 + 2*x^3)\n\njulia> p = Polynomials.basis(P, 10^9) - Polynomials.basis(P,0) # also P(Dict(0=>-1, 10^9=>1))\nSparsePolynomial(-1.0 + 1.0*x^1000000000)\n\njulia> p(1)\n0.0\n\n\n\n\n\n","category":"type"},{"location":"polynomials/polynomial/#Laurent-Polynomial","page":"Polynomial","title":"Laurent Polynomial","text":"","category":"section"},{"location":"polynomials/polynomial/","page":"Polynomial","title":"Polynomial","text":"LaurentPolynomial","category":"page"},{"location":"polynomials/polynomial/#Polynomials.LaurentPolynomial","page":"Polynomial","title":"Polynomials.LaurentPolynomial","text":"LaurentPolynomial{T,X}(coeffs::AbstractVector, [m::Integer = 0], [var = :x])\n\nA Laurent polynomial is of the form a_{m}x^m + ... + a_{n}x^n where m,n are  integers (not necessarily positive) with m <= n.\n\nThe coeffs specify a_{m}, a_{m-1}, ..., a_{n}. The argument m represents the lowest exponent of the variable in the series, and is taken to be zero by default.\n\nLaurent polynomials and standard basis polynomials promote to  Laurent polynomials. Laurent polynomials may be  converted to a standard basis  polynomial when m >= 0 .\n\nIntegration will fail if there is a x⁻¹ term in the polynomial.\n\nnote: Note\nLaurentPolynomial is axis-aware, unlike the other polynomial types in this package.\n\nExamples:\n\njulia> using Polynomials\n\njulia> P = LaurentPolynomial\nLaurentPolynomial\n\njulia> p = P([1,1,1],  -1)\nLaurentPolynomial(x⁻¹ + 1 + x)\n\njulia> q = P([1,1,1])\nLaurentPolynomial(1 + x + x²)\n\njulia> pp = Polynomial([1,1,1])\nPolynomial(1 + x + x^2)\n\njulia> p + q\nLaurentPolynomial(x⁻¹ + 2 + 2*x + x²)\n\njulia> p * q\nLaurentPolynomial(x⁻¹ + 2 + 3*x + 2*x² + x³)\n\njulia> p * pp\nLaurentPolynomial(x⁻¹ + 2 + 3*x + 2*x² + x³)\n\njulia> pp - q\nLaurentPolynomial(0)\n\njulia> derivative(p)\nLaurentPolynomial(-x⁻² + 1)\n\njulia> integrate(q)\nLaurentPolynomial(1.0*x + 0.5*x² + 0.3333333333333333*x³)\n\njulia> integrate(p)  # x⁻¹  term is an issue\nERROR: ArgumentError: Can't integrate Laurent polynomial with  `x⁻¹` term\n\njulia> integrate(P([1,1,1], -5))\nLaurentPolynomial(-0.25*x⁻⁴ - 0.3333333333333333*x⁻³ - 0.5*x⁻²)\n\njulia> x⁻¹ = inv(variable(LaurentPolynomial)) # `inv` defined on monomials\nLaurentPolynomial(1.0*x⁻¹)\n\njulia> p = Polynomial([1,2,3])\nPolynomial(1 + 2*x + 3*x^2)\n\njulia> x = variable()\nPolynomial(x)\n\njulia> x^degree(p) * p(x⁻¹) # reverses  coefficients\nLaurentPolynomial(3.0 + 2.0*x + 1.0*x²)\n\n\n\n\n\n","category":"type"},{"location":"polynomials/polynomial/#Factored-Polynomial","page":"Polynomial","title":"Factored Polynomial","text":"","category":"section"},{"location":"polynomials/polynomial/","page":"Polynomial","title":"Polynomial","text":"FactoredPolynomial","category":"page"},{"location":"polynomials/polynomial/#Polynomials.FactoredPolynomial","page":"Polynomial","title":"Polynomials.FactoredPolynomial","text":"FactoredPolynomial{T,X}\n\nA polynomial type that stores its data in a dictionary whose keys are the roots and whose values are the respective multiplicities along with a leading coefficient.\n\nThe structure is utilized for scalar multiplication, polynomial multiplication and powers, the finding of roots, and the identification of a greatest common divisor. For other operations, say addition, the operation is done after converting to the Polynomial type then converting back. (This requires the identification of the roots, so is subject to numeric issues.)\n\nExamples\n\njulia> using Polynomials\n\njulia> p = FactoredPolynomial(Dict([0=>1, 1=>2, 3=>4]))\nFactoredPolynomial(x * (x - 3)⁴ * (x - 1)²)\n\njulia> q = fromroots(FactoredPolynomial, [0,1,2,3])\nFactoredPolynomial(x * (x - 2) * (x - 3) * (x - 1))\n\njulia> p*q\nFactoredPolynomial(x² * (x - 2) * (x - 3)⁵ * (x - 1)³)\n\njulia> p^1000\nFactoredPolynomial(x¹⁰⁰⁰ * (x - 3)⁴⁰⁰⁰ * (x - 1)²⁰⁰⁰)\n\njulia> gcd(p,q)\nFactoredPolynomial(x * (x - 3) * (x - 1))\n\njulia> p = Polynomial([24, -50, 35, -10, 1])\nPolynomial(24 - 50*x + 35*x^2 - 10*x^3 + x^4)\n\njulia> q = convert(FactoredPolynomial, p) # noisy form of `factor`:\nFactoredPolynomial((x - 4.0000000000000036) * (x - 2.9999999999999942) * (x - 1.0000000000000002) * (x - 2.0000000000000018))\n\njulia> map(x->round(x, digits=12), q) # map works over factors and leading coefficient -- not coefficients in the standard basis\nFactoredPolynomial((x - 4.0) * (x - 2.0) * (x - 3.0) * (x - 1.0))\n\n\n\n\n\n","category":"type"},{"location":"polynomials/polynomial/#Rational-Function","page":"Polynomial","title":"Rational Function","text":"","category":"section"},{"location":"polynomials/polynomial/","page":"Polynomial","title":"Polynomial","text":"RationalFunction","category":"page"},{"location":"polynomials/polynomial/#Polynomials.RationalFunction","page":"Polynomial","title":"Polynomials.RationalFunction","text":"RationalFunction(p::AbstractPolynomial, q::AbstractPolynomial)\np // q\n\nCreate a rational expression (p//q) from the two polynomials. \n\nCommon factors are not cancelled by the constructor, as they are for the base Rational type. The lowest_terms(pq) function attempts that operation.\n\nFor purposes of iteration, a rational function is treated like a two-element container.\n\nExamples\n\njulia> using Polynomials\n\njulia> p,q = fromroots(Polynomial, [1,2,3]), fromroots(Polynomial, [2,3,4])\n(Polynomial(-6 + 11*x - 6*x^2 + x^3), Polynomial(-24 + 26*x - 9*x^2 + x^3))\n\njulia> pq = p // q\n(-6 + 11*x - 6*x^2 + x^3) // (-24 + 26*x - 9*x^2 + x^3)\n\njulia> lowest_terms(pq)\n(-0.333333 + 0.333333*x) // (-1.33333 + 0.333333*x)\n\njulia> pq(2.5)\n-1.0\n\njulia> pq(2) # uses first non-`0/0` ratio of `p⁽ᵏ⁾/q⁽ᵏ⁾`\n-0.5\n\njulia> pq^2\n(36 - 132*x + 193*x^2 - 144*x^3 + 58*x^4 - 12*x^5 + x^6) // (576 - 1248*x + 1108*x^2 - 516*x^3 + 133*x^4 - 18*x^5 + x^6)\n\njulia> derivative(pq)\n(-108 + 180*x - 111*x^2 + 30*x^3 - 3*x^4) // (576 - 1248*x + 1108*x^2 - 516*x^3 + 133*x^4 - 18*x^5 + x^6)\n\nnote: Note\nThe RationalFunctions.jl package was a helpful source of ideas. \n\nnote: Note\nThe ImmutablePolynomial type can not be used for rational functions, as the type requires the numerator and denominator to have the exact same type.\n\n\n\n\n\n","category":"type"},{"location":"reference/#Reference/API","page":"Reference/API","title":"Reference/API","text":"","category":"section"},{"location":"reference/","page":"Reference/API","title":"Reference/API","text":"All polynomials have the following functionality. In some cases, there is not a direct function call and therefore the polynomials have to be converted to the standard Polynomial type before continuing.","category":"page"},{"location":"reference/","page":"Reference/API","title":"Reference/API","text":"Pages = [\"reference.md\"]","category":"page"},{"location":"reference/","page":"Reference/API","title":"Reference/API","text":"DocTestSetup = quote\n  using Polynomials\nend","category":"page"},{"location":"reference/#Inspection","page":"Reference/API","title":"Inspection","text":"","category":"section"},{"location":"reference/","page":"Reference/API","title":"Reference/API","text":"coeffs\ndegree\nlength\nsize\nPolynomials.domain\nmapdomain\nchop\nchop!\ntruncate\ntruncate!\nisreal\nreal\nisintegral\nismonic","category":"page"},{"location":"reference/#Polynomials.coeffs","page":"Reference/API","title":"Polynomials.coeffs","text":"coeffs(::AbstractPolynomial)\n\nReturn the coefficient vector. For a standard basis polynomial these are [a_0, a_1, ..., a_n].\n\n\n\n\n\n","category":"function"},{"location":"reference/#Polynomials.degree","page":"Reference/API","title":"Polynomials.degree","text":"degree(::AbstractPolynomial)\n\nReturn the degree of the polynomial, i.e. the highest exponent in the polynomial that has a nonzero coefficient. The degree of the zero polynomial is defined to be -1. The default method assumes the basis polynomial, βₖ has degree k.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Base.length","page":"Reference/API","title":"Base.length","text":"length(::AbstractPolynomial)\n\nThe length of the polynomial.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Base.size","page":"Reference/API","title":"Base.size","text":"size(::AbstractPolynomial, [i])\n\nReturns the size of the polynomials coefficients, along axis i if provided.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Polynomials.domain","page":"Reference/API","title":"Polynomials.domain","text":"Polynomials.domain(::Type{<:AbstractPolynomial})\n\nReturns the domain of the polynomial.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Polynomials.mapdomain","page":"Reference/API","title":"Polynomials.mapdomain","text":"mapdomain(::Type{<:AbstractPolynomial}, x::AbstractArray)\nmapdomain(::AbstractPolynomial, x::AbstractArray)\n\nGiven values of x that are assumed to be unbounded (-∞, ∞), return values rescaled to the domain of the given polynomial.\n\nExamples\n\njulia> using Polynomials\n\njulia> x = -10:10\n-10:10\n\njulia> extrema(mapdomain(ChebyshevT, x))\n(-1.0, 1.0)\n\n\n\n\n\n\n","category":"function"},{"location":"reference/#Base.chop","page":"Reference/API","title":"Base.chop","text":"chop(::AbstractPolynomial{T};\n    rtol::Real = Base.rtoldefault(real(T)), atol::Real = 0))\n\nRemoves any leading coefficients that are approximately 0 (using rtol and atol with norm(p)). Returns a polynomial whose degree will guaranteed to be equal to or less than the given polynomial's.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Polynomials.chop!","page":"Reference/API","title":"Polynomials.chop!","text":"chop!(::AbstractPolynomial{T};\n    rtol::Real = Base.rtoldefault(real(T)), atol::Real = 0))\n\nIn-place version of chop\n\n\n\n\n\n","category":"function"},{"location":"reference/#Base.truncate","page":"Reference/API","title":"Base.truncate","text":"truncate(::AbstractPolynomial{T};\n    rtol::Real = Base.rtoldefault(real(T)), atol::Real = 0)\n\nRounds off coefficients close to zero, as determined by rtol and atol, and then chops any leading zeros. Returns a new polynomial.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Polynomials.truncate!","page":"Reference/API","title":"Polynomials.truncate!","text":"truncate!(::AbstractPolynomial{T};\n    rtol::Real = Base.rtoldefault(real(T)), atol::Real = 0)\n\nIn-place version of truncate\n\n\n\n\n\n","category":"function"},{"location":"reference/#Base.isreal","page":"Reference/API","title":"Base.isreal","text":"isreal(p::AbstractPolynomial)\n\nDetermine whether a polynomial is a real polynomial, i.e., having only real numbers as coefficients.\n\nSee also: real\n\n\n\n\n\n","category":"function"},{"location":"reference/#Base.real","page":"Reference/API","title":"Base.real","text":"real(p::AbstractPolynomial)\n\nConstruct a real polynomial from the real parts of the coefficients of p.\n\nSee also: isreal\n\nnote: Note\nThis could cause losing terms in p. This method is usually called on polynomials like p = Polynomial([1, 2 + 0im, 3.0, 4.0 + 0.0im]) where you want to chop the imaginary parts of the coefficients of p.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Polynomials.isintegral","page":"Reference/API","title":"Polynomials.isintegral","text":"isintegral(p::AbstractPolynomial)\n\nDetermine whether a polynomial is an integer polynomial, i.e., having only integers as coefficients.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Polynomials.ismonic","page":"Reference/API","title":"Polynomials.ismonic","text":"ismonic(p::AbstractPolynomial)\n\nDetermine whether a polynomial is a monic polynomial, i.e., its leading coefficient is one.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Arithmetic","page":"Reference/API","title":"Arithmetic","text":"","category":"section"},{"location":"reference/","page":"Reference/API","title":"Reference/API","text":"All AbstractPolynomials have basic arithmetic operations defined on them (+, -, *, /, ÷, %, ==).","category":"page"},{"location":"reference/","page":"Reference/API","title":"Reference/API","text":"julia> p = Polynomial([1, 2])\nPolynomial(1 + 2*x)\n\njulia> q = Polynomial([1, 0, -1])\nPolynomial(1 - x^2)\n\njulia> 2p\nPolynomial(2 + 4*x)\n\njulia> 2 + p\nPolynomial(3 + 2*x)\n\njulia> p - q\nPolynomial(2*x + x^2)\n\njulia> p * q\nPolynomial(1 + 2*x - x^2 - 2*x^3)\n\njulia> q / 2\nPolynomial(0.5 - 0.5*x^2)","category":"page"},{"location":"reference/","page":"Reference/API","title":"Reference/API","text":"gcd","category":"page"},{"location":"reference/#Base.gcd","page":"Reference/API","title":"Base.gcd","text":"gcd(a::AbstractPolynomial, b::AbstractPolynomial; atol::Real=0, rtol::Real=Base.rtoldefault)\n\nFind the greatest common denominator of two polynomials recursively using Euclid's algorithm.\n\nExamples\n\njulia> using Polynomials\n\njulia> gcd(fromroots([1, 1, 2]), fromroots([1, 2, 3]))\nPolynomial(4.0 - 6.0*x + 2.0*x^2)\n\n\n\n\n\n\ngcd(p1::StandardBasisPolynomial, p2::StandardBasisPolynomial; method=:euclidean, kwargs...)\n\nFind the greatest common divisor.\n\nBy default, uses the Euclidean division algorithm (method=:euclidean), which is susceptible to floating point issues.\n\nPassing method=:noda_sasaki uses scaling to circumvent some of these.\n\nPassing method=:numerical will call the internal method NGCD.ngcd for the numerical gcd. See the help page of Polynomials.NGCD.ngcd(p,q) for details.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Mathematical-Functions","page":"Reference/API","title":"Mathematical Functions","text":"","category":"section"},{"location":"reference/","page":"Reference/API","title":"Reference/API","text":"zero\none\nvariable\nfromroots\nroots\nderivative\nintegrate\nfit\ncompanion\nvander","category":"page"},{"location":"reference/#Base.zero","page":"Reference/API","title":"Base.zero","text":"zero(::Type{<:AbstractPolynomial})\nzero(::AbstractPolynomial)\n\nReturns a representation of 0 as the given polynomial.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Base.one","page":"Reference/API","title":"Base.one","text":"one(::Type{<:AbstractPolynomial})\none(::AbstractPolynomial)\n\nReturns a representation of 1 as the given polynomial.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Polynomials.variable","page":"Reference/API","title":"Polynomials.variable","text":"variable(var=:x)\nvariable(::Type{<:AbstractPolynomial}, var=:x)\nvariable(p::AbstractPolynomial, var=indeterminate(p))\n\nReturn the monomial x in the indicated polynomial basis.  If no type is give, will default to Polynomial. Equivalent  to  P(var).\n\nExamples\n\njulia> using Polynomials\n\njulia> x = variable()\nPolynomial(x)\n\njulia> p = 100 + 24x - 3x^2\nPolynomial(100 + 24*x - 3*x^2)\n\njulia> roots((x - 3) * (x + 2))\n2-element Vector{Float64}:\n -2.0\n  3.0\n\n\n\n\n\n\n","category":"function"},{"location":"reference/#Polynomials.fromroots","page":"Reference/API","title":"Polynomials.fromroots","text":"fromroots(::AbstractVector{<:Number}; var=:x)\nfromroots(::Type{<:AbstractPolynomial}, ::AbstractVector{<:Number}; var=:x)\n\nConstruct a polynomial of the given type given the roots. If no type is given, defaults to Polynomial.\n\nExamples\n\njulia> using Polynomials\n\njulia> r = [3, 2]; # (x - 3)(x - 2)\n\njulia> fromroots(r)\nPolynomial(6 - 5*x + x^2)\n\n\n\n\n\nfromroots(::AbstractMatrix{<:Number}; var=:x)\nfromroots(::Type{<:AbstractPolynomial}, ::AbstractMatrix{<:Number}; var=:x)\n\nConstruct a polynomial of the given type using the eigenvalues of the given matrix as the roots. If no type is given, defaults to Polynomial.\n\nExamples\n\njulia> using Polynomials\n\njulia> A = [1 2; 3 4]; # (x - 5.37228)(x + 0.37228)\n\njulia> fromroots(A)\nPolynomial(-1.9999999999999998 - 5.0*x + 1.0*x^2)\n\n\n\n\n\n","category":"function"},{"location":"reference/#Polynomials.roots","page":"Reference/API","title":"Polynomials.roots","text":"roots(::AbstractPolynomial; kwargs...)\n\nReturns the roots, or zeros, of the given polynomial.\n\nFor non-factored, standard basis polynomials the roots are calculated via the eigenvalues of the companion matrix. The kwargs are passed to the LinearAlgebra.eigvals call.\n\nnote: Note\nThe default roots implementation is for polynomials in the standard basis. The companion matrix approach is reasonably fast and accurate for modest-size polynomials. However, other packages in the Julia ecosystem may be of interest and are mentioned in the documentation.\n\n\n\n\n\nroots(p)\n\nCompute the roots of the Laurent polynomial p.\n\nThe roots of a function (Laurent polynomial in this case) a(z) are the values of z for which the function vanishes. A Laurent polynomial a(z) = a_m z^m + a_m+1 z^m+1 +  + a_-1 z^-1 + a_0 + a_1 z +  + a_n-1 z^n-1 + a_n z^n can equivalently be viewed as a rational function with a multiple singularity (pole) at the origin. The roots are then the roots of the numerator polynomial. For example, a(z) = 1z + 2 + z can be written as a(z) = (1+2z+z^2)  z and the roots of a are the roots of 1+2z+z^2.\n\nExample\n\njulia> using Polynomials;\n\njulia> p = LaurentPolynomial([24,10,-15,0,1],-2,:z)\nLaurentPolynomial(24*z⁻² + 10*z⁻¹ - 15 + z²)\n\njulia> roots(p)\n4-element Vector{Float64}:\n -3.999999999999999\n -0.9999999999999994\n  1.9999999999999998\n  2.9999999999999982\n\n\n\n\n\nroots(pq::AbstractRationalFunction; kwargs...)\n\nReturn the zeros of the rational function (after cancelling commong factors, the zeros are the roots of the numerator.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Polynomials.derivative","page":"Reference/API","title":"Polynomials.derivative","text":"derivative(::AbstractPolynomial, order::Int = 1)\n\nReturns a polynomial that is the orderth derivative of the given polynomial. order must be non-negative.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Polynomials.integrate","page":"Reference/API","title":"Polynomials.integrate","text":"integrate(p::AbstractPolynomial)\n\nReturn an antiderivative for p\n\n\n\n\n\nintegrate(::AbstractPolynomial, C)\n\nReturns the indefinite integral of the polynomial with constant C when expressed in the standard basis.\n\n\n\n\n\nintegrate(::AbstractPolynomial, a, b)\n\nCompute the definite integral of the given polynomial from a to b. Will throw an error if either a or b are out of the polynomial's domain.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Polynomials.fit","page":"Reference/API","title":"Polynomials.fit","text":"fit(x, y, deg=length(x) - 1; [weights], var=:x)\nfit(::Type{<:AbstractPolynomial}, x, y, deg=length(x)-1; [weights], var=:x)\n\nFit the given data as a polynomial type with the given degree. Uses linear least squares to minimize the norm  ||y - V⋅β||^2, where V is the Vandermonde matrix and β are the coefficients of the polynomial fit.\n\nThis will automatically scale your data to the domain of the polynomial type using mapdomain. The default polynomial type is Polynomial.\n\nWeights\n\nWeights may be assigned to the points by specifying a vector or matrix of weights.\n\nWhen specified as a vector, [w₁,…,wₙ], the weights should be non-negative as the minimization problem is argmin_β Σᵢ wᵢ |yᵢ - Σⱼ Vᵢⱼ βⱼ|² = argmin_β || √(W)⋅(y - V(x)β)||², where, W the diagonal matrix formed from [w₁,…,wₙ], is used for the solution, V being the Vandermonde matrix of x corresponding to the specified degree. This parameterization of the weights is different from that of numpy.polyfit, where the weights would be specified through [ω₁,ω₂,…,ωₙ] = [√w₁, √w₂,…,√wₙ] with the answer solving argminᵦ | (ωᵢ⋅yᵢ- ΣⱼVᵢⱼ(ω⋅x) βⱼ) |^2.\n\nWhen specified as a matrix, W, the solution is through the normal equations (VᵀWV)β = (Vᵀy), again V being the Vandermonde matrix of x corresponding to the specified degree.\n\n(In statistics, the vector case corresponds to weighted least squares, where weights are typically given by wᵢ = 1/σᵢ², the σᵢ² being the variance of the measurement; the matrix specification follows that of the generalized least squares estimator with W = Σ⁻¹, the inverse of the variance-covariance matrix.)\n\nlarge degree\n\nFor fitting with a large degree, the Vandermonde matrix is exponentially ill-conditioned. The ArnoldiFit type introduces an Arnoldi orthogonalization that fixes this problem.\n\n\n\n\n\nfit(P::Type{<:StandardBasisPolynomial}, x, y, J, [cs::Dict{Int, T}]; weights, var)\n\nUsing constrained least squares, fit a polynomial of the type p = ∑_{i ∈ J} aᵢ xⁱ + ∑ cⱼxʲ where cⱼ are fixed non-zero constants\n\nJ: a collection of degrees to find coefficients for\ncs: If given, a Dict of key/values, i => cᵢ, which indicate the degree and value of the fixed non-zero constants.\n\nThe degrees in cs and those in J should not intersect.\n\nExample\n\nx = range(0, pi/2, 10)\ny = sin.(x)\nP = Polynomial\np0 = fit(P, x, y, 5)\np1 = fit(P, x, y, 1:2:5)\np2 = fit(P, x, y, 3:2:5, Dict(1 => 1))\n[norm(p.(x) - y) for p ∈ (p0, p1, p2)] # 1.7e-5, 0.00016, 0.000248\n\n\n\n\n\nfit(::Type{RationalFunction}, xs::AbstractVector{S}, ys::AbstractVector{T}, m, n; var=:x)\n\nFit a rational function of the form pq = (a₀ + a₁x¹ + … + aₘxᵐ) / (1 + b₁x¹ + … + bₙxⁿ) to the data (x,y).\n\nnote: Note\nThis uses a simple implementation of the Gauss-Newton method to solve the non-linear least squares problem: minᵦ Σ(yᵢ - pq(xᵢ,β)², where β=(a₀,a₁,…,aₘ,b₁,…,bₙ).A more rapidly convergent method is used in the LsqFit.jl package, and if performance is important, re-expressing the problem for use with that package is suggested.Further, if an accurate rational function fit of adaptive degrees is of interest, the BaryRational.jl package provides an implementation of the AAA algorithm (\"which offers speed, flexibility, and robustness we have not seen in other algorithms\" Nakatsukasa, Sète, Trefethen) and one using Floater-Hormann weights Floater, Hormann (\"that have no real poles and arbitrarily high approximation orders on any real interval, regardless of the distribution of the points\")The RationalApproximations package also has implementations of the AAA algorithm.A python library, polyrat, has implementations of other algorithms.\n\nExample\n\njulia> x = variable(Polynomial{Float64})\nPolynomial(1.0*x)\n\njulia> pq = (1+x)//(1-x)\n(1.0 + 1.0*x) // (1.0 - 1.0*x)\n\njulia> xs = 2.0:.1:3;\n\njulia> ys = pq.(xs);\n\njulia> v = fit(RationalFunction, xs, ys, 2, 2)\n(1.0 + 1.0*x - 6.82121e-13*x^2) // (1.0 - 1.0*x + 2.84217e-13*x^2)\n\njulia> maximum(abs, v(x)-pq(x) for x ∈ 2.1:0.1:3.0)\n1.06314956838105e-12\n\njulia> using BaryRational\n\njulia> u = aaa(xs,ys)\n(::BaryRational.AAAapprox{Vector{Float64}}) (generic function with 1 method)\n\njulia> maximum(abs, u(x)-pq(x) for x ∈ 2.1:0.1:3.0)\n4.440892098500626e-16\n\njulia> u(variable(pq)) # to see which polynomial is used\n(2.68328 + 0.447214*x - 1.78885*x^2 + 0.447214*x^3) // (2.68328 - 4.91935*x + 2.68328*x^2 - 0.447214*x^3)\n\n\n\n\n\nfit(::Type{RationalFunction}, r::Polynomial, m, n; var=:x)\n\nFit a Pade approximant (pade_fit) to r.\n\nExamples:\n\njulia> using Polynomials, PolynomialRatios\n\njulia> x = variable()\nPolynomial(x)\n\njulia> ex = 1 + x + x^2/2 + x^3/6 + x^4/24 + x^5/120 # Taylor polynomial for e^x\nPolynomial(1.0 + 1.0*x + 0.5*x^2 + 0.16666666666666666*x^3 + 0.041666666666666664*x^4 + 0.008333333333333333*x^5)\n\njulia> maximum(abs, exp(x) - fit(RationalFunction, ex, 1,1)(x) for x ∈ 0:.05:0.5)\n0.017945395966538547\n\njulia> maximum(abs, exp(x) - fit(RationalFunction, ex, 1,2)(x) for x ∈ 0:.05:0.5)\n0.0016624471707165078\n\njulia> maximum(abs, exp(x) - fit(RationalFunction, ex, 2,1)(x) for x ∈ 0:.05:0.5)\n0.001278729299871717\n\njulia> maximum(abs, exp(x) - fit(RationalFunction, ex, 2,2)(x) for x ∈ 0:.05:0.5)\n7.262205147950951e-5\n\n\n\n\n\n","category":"function"},{"location":"reference/#Polynomials.companion","page":"Reference/API","title":"Polynomials.companion","text":"companion(::AbstractPolynomial)\n\nReturn the companion matrix for the given polynomial.\n\nReferences\n\nCompanion Matrix\n\n\n\n\n\n","category":"function"},{"location":"reference/#Polynomials.vander","page":"Reference/API","title":"Polynomials.vander","text":"vander(::Type{AbstractPolynomial}, x::AbstractVector, deg::Integer)\n\nCalculate the pseudo-Vandermonde matrix of the given polynomial type with the given degree.\n\nReferences\n\nVandermonde Matrix\n\n\n\n\n\n","category":"function"},{"location":"reference/#Plotting","page":"Reference/API","title":"Plotting","text":"","category":"section"},{"location":"reference/","page":"Reference/API","title":"Reference/API","text":"Polynomials can be plotted directly using Plots.jl or Makie.jl.","category":"page"},{"location":"reference/","page":"Reference/API","title":"Reference/API","text":"plot(::AbstractPolynomial; kwds...)","category":"page"},{"location":"reference/","page":"Reference/API","title":"Reference/API","text":"will automatically determine a range based on the critical points (roots, extrema and points of inflection).","category":"page"},{"location":"reference/","page":"Reference/API","title":"Reference/API","text":"plot(::AbstractPolynomial, a, b; kwds...)","category":"page"},{"location":"reference/","page":"Reference/API","title":"Reference/API","text":"will plot the polynomial within the range [a, b].","category":"page"},{"location":"reference/#Example:-The-Polynomials.jl-logo","page":"Reference/API","title":"Example: The Polynomials.jl logo","text":"","category":"section"},{"location":"reference/","page":"Reference/API","title":"Reference/API","text":"using Plots, Polynomials\n# T1, T2, T3, and T4:\nchebs = [\n  ChebyshevT([0, 1]),\n  ChebyshevT([0, 0, 1]),\n  ChebyshevT([0, 0, 0, 1]),\n  ChebyshevT([0, 0, 0, 0, 1]),\n]\ncolors = [\"#4063D8\", \"#389826\", \"#CB3C33\", \"#9558B2\"]\n\np = plot(legend=false, label=\"\")\nfor (cheb, col) in zip(chebs, colors)\n  plot!(cheb, c=col, lw=5)\nend\nsavefig(\"chebs.svg\"); nothing # hide","category":"page"},{"location":"reference/","page":"Reference/API","title":"Reference/API","text":"(Image: )","category":"page"},{"location":"#Polynomials.jl","page":"Home","title":"Polynomials.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Polynomials.jl is a Julia package that provides basic arithmetic, integration, differentiation, evaluation, and root finding for univariate polynomials.","category":"page"},{"location":"","page":"Home","title":"Home","text":"To install the package, run","category":"page"},{"location":"","page":"Home","title":"Home","text":"(v1.6) pkg> add Polynomials","category":"page"},{"location":"","page":"Home","title":"Home","text":"As of version v3.0.0 Julia version 1.6 or higher is required.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The package can then be loaded into the current session through","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Polynomials","category":"page"},{"location":"","page":"Home","title":"Home","text":"DocTestSetup = quote\n  using Polynomials\nend","category":"page"},{"location":"#Quick-Start","page":"Home","title":"Quick Start","text":"","category":"section"},{"location":"#Construction-and-Evaluation","page":"Home","title":"Construction and Evaluation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Construct a polynomial from its coefficients, lowest order first.","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> Polynomial([1,0,3,4])\nPolynomial(1 + 3*x^2 + 4*x^3)","category":"page"},{"location":"","page":"Home","title":"Home","text":"An optional variable parameter can be added.","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> Polynomial([1,2,3], :s)\nPolynomial(1 + 2*s + 3*s^2)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Construct a polynomial from its roots.","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> fromroots([1,2,3]) # (x-1)*(x-2)*(x-3)\nPolynomial(-6 + 11*x - 6*x^2 + x^3)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Evaluate the polynomial p at x.","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> p = Polynomial([1, 0, -1])\nPolynomial(1 - x^2)\n\njulia> p(1)\n0\n","category":"page"},{"location":"","page":"Home","title":"Home","text":"The Polynomial constructor stores all coefficients using the standard basis with a vector. Other types (e.g. ImmutablePolynomial, SparsePolynomial, or FactoredPolynomial) use different back-end containers which may have advantage for some uses.","category":"page"},{"location":"#Arithmetic","page":"Home","title":"Arithmetic","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The usual arithmetic operators are overloaded to work on polynomials, and combinations of polynomials and scalars.","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> p = Polynomial([1,2])\nPolynomial(1 + 2*x)\n\njulia> q = Polynomial([1, 0, -1])\nPolynomial(1 - x^2)\n\njulia> 2p\nPolynomial(2 + 4*x)\n\njulia> 2 + p\nPolynomial(3 + 2*x)\n\njulia> p - q\nPolynomial(2*x + x^2)\n\njulia> p * q\nPolynomial(1 + 2*x - x^2 - 2*x^3)\n\njulia> q / 2\nPolynomial(0.5 - 0.5*x^2)\n\njulia> q ÷ p  # `div`, also `rem` and `divrem`\nPolynomial(0.25 - 0.5*x)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Note that operations involving polynomials with different variables will error.","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> p = Polynomial([1, 2, 3], :x)\nPolynomial(1 + 2*x + 3*x^2)\n\njulia> q = Polynomial([1, 2, 3], :s)\nPolynomial(1 + 2*s + 3*s^2)\n\njulia> p + q\nERROR: ArgumentError: Polynomials have different indeterminates\n[...]","category":"page"},{"location":"","page":"Home","title":"Home","text":"Except for operations involving constant polynomials.","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> p = Polynomial([1, 2, 3], :x)\nPolynomial(1 + 2*x + 3*x^2)\n\njulia> q = Polynomial(1, :y)\nPolynomial(1)\n\njulia> p+q\nPolynomial(2 + 2*x + 3*x^2)","category":"page"},{"location":"#Integrals-and-Derivatives","page":"Home","title":"Integrals and Derivatives","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Integrate the polynomial p term by term, optionally adding constant term C. The degree of the resulting polynomial is one higher than the degree of p.","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> integrate(Polynomial([1, 0, -1]))\nPolynomial(1.0*x - 0.3333333333333333*x^3)\n\njulia> integrate(Polynomial([1, 0, -1]), 2)\nPolynomial(2.0 + 1.0*x - 0.3333333333333333*x^3)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Differentiate the polynomial p term by term. The degree of the resulting polynomial is one lower than the degree of p, unless p is a zero polynomial.","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> derivative(Polynomial([1, 3, -1]))\nPolynomial(3 - 2*x)","category":"page"},{"location":"#Root-finding","page":"Home","title":"Root-finding","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Return the d roots (or zeros) of the degree d polynomial p.","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> roots(Polynomial([1, 0, -1]))\n2-element Vector{Float64}:\n -1.0\n  1.0\n\njulia> roots(Polynomial([1, 0, 1]))\n2-element Vector{ComplexF64}:\n 0.0 - 1.0im\n 0.0 + 1.0im\n\njulia> roots(Polynomial([0, 0, 1]))\n2-element Vector{Float64}:\n 0.0\n 0.0","category":"page"},{"location":"","page":"Home","title":"Home","text":"By design, this is not type-stable; the returned roots may be real or complex.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The default roots function uses the eigenvalues of the companion matrix for a polynomial. This is an 𝑶(n^3) operation.","category":"page"},{"location":"","page":"Home","title":"Home","text":"For polynomials with BigFloat coefficients, the GenericLinearAlgebra package can be seamlessly used:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> p = fromroots(Polynomial{BigFloat}, [1,2,3])\nPolynomial(-6.0 + 11.0*x - 6.0*x^2 + 1.0*x^3)\n\njulia> roots(p)\nERROR: MethodError: no method matching eigvals!(::Matrix{BigFloat})\n[...]\n\njulia> using GenericLinearAlgebra\n\njulia> roots(p)\n3-element Vector{Complex{BigFloat}}:\n 0.9999999999999999999999999999999999999999999999999999999999999999999999999999655 + 0.0im\n  1.999999999999999999999999999999999999999999999999999999999999999999999999999931 - 0.0im\n  2.999999999999999999999999999999999999999999999999999999999999999999999999999793 + 0.0im","category":"page"},{"location":"#Comments-on-root-finding","page":"Home","title":"Comments on root finding","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The PolynomialRoots.jl package provides an alternative approach for finding complex roots to univariate polynomials that is more performant than roots. It is based on an algorithm of Skowron and Gould.","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> import PolynomialRoots # import as `roots` conflicts\n\njulia> p = fromroots(Polynomial, [1,2,3])\nPolynomial(-6 + 11*x - 6*x^2 + x^3)\n\njulia> PolynomialRoots.roots(coeffs(p))\n3-element Vector{ComplexF64}:\n  3.000000000000001 - 0.0im\n 1.9999999999999993 + 0.0im\n 1.0000000000000002 + 0.0im","category":"page"},{"location":"","page":"Home","title":"Home","text":"The roots are always returned as complex numbers.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The FastPolynomialRoots package provides an interface to FORTRAN code implementing an algorithm of Aurentz, Mach, Robol, Vandrebril, and Watkins. that can handle very large polynomials (it is 𝑶(n^2) and backward stable). The AMRVW.jl package implements the algorithm in Julia, allowing the use of other number types.","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> import AMRVW # import as `roots` conflicts\n\njulia> AMRVW.roots(float.(coeffs(p)))\n3-element Vector{ComplexF64}:\n 0.9999999999999997 + 0.0im\n 2.0000000000000036 + 0.0im\n 2.9999999999999964 + 0.0im","category":"page"},{"location":"","page":"Home","title":"Home","text":"The roots are returned as complex numbers.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Both PolynomialRoots and AMRVW are generic and work with BigFloat coefficients, for example.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The AMRVW package works with much larger polynomials than either roots or Polynomial.roots. For example, the roots of this 1000 degree random polynomial are quickly and accurately solved for:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> filter(isreal, AMRVW.roots(rand(1001) .- 1/2))\n2-element Vector{ComplexF64}:\n  0.993739974989572 + 0.0im\n 1.0014677846996498 + 0.0im","category":"page"},{"location":"","page":"Home","title":"Home","text":"The Hecke package has a roots function. The Hecke package utilizes the Arb library for performant, high-precision numbers:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> import Hecke # import as `roots` conflicts\n\njulia> Qx, x = Hecke.PolynomialRing(Hecke.QQ)\n(Univariate Polynomial Ring in x over Rational Field, x)\n\njulia> q = (x-1)*(x-2)*(x-3)\nx^3 - 6*x^2 + 11*x - 6\n\njulia> Hecke.roots(q)\n3-element Vector{Nemo.fmpq}:\n 2\n 1\n 3","category":"page"},{"location":"","page":"Home","title":"Home","text":"This next polynomial has 3 real roots, 2 of which are in a cluster; Hecke quickly identifies them:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> p = -1 + 254*x - 16129*x^2 + 1*x^17\nx^17 - 16129*x^2 + 254*x - 1\n\njulia> filter(isreal, Hecke._roots(p, 200)) # `_roots` not `roots`\n3-element Vector{Nemo.acb}:\n [0.007874015748031496052667730054749907629383970426203662570129818116411192289734968717460531379762086419 +/- 3.10e-103]\n [0.0078740157480314960733165219137540296086246589982151627453855179522742093785877068332663198273096875302 +/- 9.31e-104]\n [1.9066348541790688341521872066398429982632947292434604847312536201982593209326201234353468172497707769372732739429697289 +/- 7.14e-119]","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"To find just the real roots of a polynomial with real coefficients there are a few additional options to solving for all the roots and filtering by isreal.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The package IntervalRootFinding identifies real zeros of univariate functions and can be used to find isolating intervals for the real roots. For example,","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using Polynomials, IntervalArithmetic\n\njulia> import IntervalRootFinding # its `roots` method conflicts with `roots`\n\njulia> p = fromroots(Polynomial, [1,2,3])\nPolynomial(-6 + 11*x - 6*x^2 + x^3)\n\njulia> IntervalRootFinding.roots(x -> p(x), 0..10)\n3-element Vector{IntervalRootFinding.Root{Interval{Float64}}}:\n Root([0.999999, 1.00001], :unique)\n Root([1.99999, 2.00001], :unique)\n Root([2.99999, 3.00001], :unique)","category":"page"},{"location":"","page":"Home","title":"Home","text":"The output is a set of intervals. Those flagged with :unique are guaranteed to contain a unique root.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The RealPolynomialRoots package provides a function ANewDsc to find isolating intervals for  the roots of a square-free polynomial, specified through its coefficients:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using RealPolynomialRoots\n\njulia> st = ANewDsc(coeffs(p))\nThere were 3 isolating intervals found:\n[2.62…, 3.62…]₂₅₆\n[1.5…, 2.62…]₂₅₆\n[-0.50…, 1.5…]₂₅₆","category":"page"},{"location":"","page":"Home","title":"Home","text":"These isolating intervals can be refined to find numeric estimates for the roots over BigFloat values.","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> refine_roots(st)\n3-element Vector{BigFloat}:\n 2.99999999999999999999...\n 2.00000000000000000000...\n 1.00000000000000000000...","category":"page"},{"location":"","page":"Home","title":"Home","text":"This specialized algorithm can identify very nearby roots. For example, returning to this Mignotte-type polynomial:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> p = SparsePolynomial(Dict(0=>-1, 1=>254, 2=>-16129, 17=>1))\nSparsePolynomial(-1 + 254*x - 16129*x^2 + x^17)\n\njulia> ANewDsc(coeffs(p))\nThere were 3 isolating intervals found:\n[1.5…, 3.5…]₅₃\n[0.0078740157480314960682066…, 0.0078740157480314960873178…]₁₃₉\n[0.0078740157480314960492543…, 0.0078740157480314960682066…]₁₃₉","category":"page"},{"location":"","page":"Home","title":"Home","text":"IntervalRootFinding has issues disambiguating the clustered roots of this example:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> IntervalRootFinding.roots(x -> p(x), 0..3.5)\n7-element Vector{IntervalRootFinding.Root{Interval{Float64}}}:\n Root([1.90663, 1.90664], :unique)\n Root([0.00787464, 0.00787468], :unknown)\n Root([0.00787377, 0.00787387], :unknown)\n Root([0.00787405, 0.00787412], :unknown)\n Root([0.00787396, 0.00787406], :unknown)\n Root([0.00787425, 0.00787431], :unknown)\n Root([0.00787394, 0.00787397], :unknown)","category":"page"},{"location":"","page":"Home","title":"Home","text":"For this example, filter(isreal, Hecke._roots(p)) also isolates the three real roots, but not quite as quickly.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Most of the root finding algorithms have issues when the roots have multiplicities. For example, both ANewDsc and Hecke.roots assume a square free polynomial. For non-square free polynomials:","category":"page"},{"location":"","page":"Home","title":"Home","text":"The Polynomials.Multroot.multroot function is available  for finding the roots of a polynomial and their multiplicities. This is based on work of Zeng.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Here we see IntervalRootFinding.roots having trouble isolating the roots due to the multiplicities:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> p = fromroots(Polynomial, [1,2,2,3,3])\nPolynomial(-36 + 96*x - 97*x^2 + 47*x^3 - 11*x^4 + x^5)\n\njulia> IntervalRootFinding.roots(x -> p(x), 0..10)\n335-element Vector{IntervalRootFinding.Root{Interval{Float64}}}:\n Root([1.99999, 2], :unknown)\n Root([1.99999, 2], :unknown)\n Root([3, 3.00001], :unknown)\n Root([2.99999, 3], :unknown)\n ⋮\n Root([2.99999, 3], :unknown)\n Root([2, 2.00001], :unknown)","category":"page"},{"location":"","page":"Home","title":"Home","text":"The roots function identifies the roots, but the multiplicities would need identifying:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> roots(p)\n5-element Vector{Float64}:\n 1.000000000000011\n 1.9999995886034314\n 2.0000004113969276\n 2.9999995304339646\n 3.0000004695656672","category":"page"},{"location":"","page":"Home","title":"Home","text":"Whereas, the roots along with the multiplicity structure are correctly identified with multroot:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> Polynomials.Multroot.multroot(p)\n(values = [1.0000000000000004, 1.9999999999999984, 3.0000000000000018], multiplicities = [1, 2, 2], κ = 35.11176306900731, ϵ = 0.0)","category":"page"},{"location":"","page":"Home","title":"Home","text":"The square_free function can help:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> q = Polynomials.square_free(p)\nANewDsc(q)\nPolynomial(-0.20751433915978448 + 0.38044295512633425*x - 0.20751433915986722*x^2 + 0.03458572319332053*x^3)\n\njulia> IntervalRootFinding.roots(x -> q(x), 0..10)\n3-element Vector{IntervalRootFinding.Root{Interval{Float64}}}:\n Root([0.999999, 1.00001], :unique)\n Root([1.99999, 2.00001], :unique)\n Root([2.99999, 3.00001], :unique)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Similarly:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> ANewDsc(coeffs(q))\nThere were 3 isolating intervals found:\n[2.62…, 3.62…]₂₅₆\n[1.5…, 2.62…]₂₅₆\n[-0.50…, 1.5…]₂₅₆","category":"page"},{"location":"#Fitting-arbitrary-data","page":"Home","title":"Fitting arbitrary data","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Fit a polynomial (of degree deg) to x and y using polynomial interpolation or a (weighted) least-squares approximation.","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Plots, Polynomials\nxs = range(0, 10, length=10)\nys = @. exp(-xs)\nf = fit(xs, ys) # degree = length(xs) - 1\nf2 = fit(xs, ys, 2) # degree = 2\n\nscatter(xs, ys, markerstrokewidth=0, label=\"Data\")\nplot!(f, extrema(xs)..., label=\"Fit\")\nplot!(f2, extrema(xs)..., label=\"Quadratic Fit\")\nsavefig(\"polyfit.svg\"); nothing # hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: )","category":"page"},{"location":"#Other-bases","page":"Home","title":"Other bases","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A polynomial, e.g. a_0 + a_1 x + a_2 x^2 + ... + a_n x^n, can be seen as a collection of coefficients, [a_0, a_1, ..., a_n], relative to some polynomial basis. The most  familiar basis being  the standard one: 1, x, x^2, ...  Alternative bases are possible.  The ChebyshevT polynomials are  implemented, as an example. Instead of Polynomial  or  Polynomial{T}, ChebyshevT or  ChebyshevT{T} constructors are used:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> p1 = ChebyshevT([1.0, 2.0, 3.0])\nChebyshevT(1.0⋅T_0(x) + 2.0⋅T_1(x) + 3.0⋅T_2(x))\n\njulia> p2 = ChebyshevT{Float64}([0, 1, 2])\nChebyshevT(1.0⋅T_1(x) + 2.0⋅T_2(x))\n\njulia> p1 + p2\nChebyshevT(1.0⋅T_0(x) + 3.0⋅T_1(x) + 5.0⋅T_2(x))\n\njulia> p1 * p2\nChebyshevT(4.0⋅T_0(x) + 4.5⋅T_1(x) + 3.0⋅T_2(x) + 3.5⋅T_3(x) + 3.0⋅T_4(x))\n\njulia> derivative(p1)\nChebyshevT(2.0⋅T_0(x) + 12.0⋅T_1(x))\n\njulia> integrate(p2)\nChebyshevT(- 1.0⋅T_1(x) + 0.25⋅T_2(x) + 0.3333333333333333⋅T_3(x))\n\njulia> convert(Polynomial, p1)\nPolynomial(-2.0 + 2.0*x + 6.0*x^2)\n\njulia> convert(ChebyshevT, Polynomial([1.0, 2,  3]))\nChebyshevT(2.5⋅T_0(x) + 2.0⋅T_1(x) + 1.5⋅T_2(x))","category":"page"},{"location":"","page":"Home","title":"Home","text":"warning: Warning\nThe older  Poly type that this package used prior to v0.7  is implemented as an alternate basis  to provide support for older code bases. As of v1.0,  this type will be only available by executing using Polynomials.PolyCompat.","category":"page"},{"location":"#Iteration","page":"Home","title":"Iteration","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If its basis is implicit, then a polynomial may be  seen as just a vector of  coefficients. Vectors are 1-based, but, for convenience, most polynomial types are naturally 0-based, for purposes of indexing (e.g. getindex, setindex!, eachindex). Iteration over a polynomial steps through the underlying coefficients.","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> as = [1,2,3,4,5]; p = Polynomial(as);\n\njulia> as[3], p[2], collect(p)[3]\n(3, 3, 3)","category":"page"},{"location":"","page":"Home","title":"Home","text":"The pairs iterator, iterates over the indices and coefficients, attempting to match how pairs applies to the underlying storage model:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> v = [1,2,0,4]\n4-element Vector{Int64}:\n 1\n 2\n 0\n 4\n\njulia> p,ip,sp,lp = Polynomial(v), ImmutablePolynomial(v), SparsePolynomial(v), LaurentPolynomial(v, -1);\n\njulia> collect(pairs(p))\n4-element Vector{Pair{Int64, Int64}}:\n 0 => 1\n 1 => 2\n 2 => 0\n 3 => 4\n\njulia> collect(pairs(ip)) == collect(pairs(p))\ntrue\n\njulia> collect(pairs(sp)) # unordered dictionary with only non-zero terms\n3-element Vector{Pair{Int64, Int64}}:\n 0 => 1\n 3 => 4\n 1 => 2\n\njulia> collect(pairs(lp))\n4-element Vector{Pair{Int64, Int64}}:\n -1 => 1\n  0 => 2\n  1 => 0\n  2 => 4","category":"page"},{"location":"","page":"Home","title":"Home","text":"The unexported monomials iterator iterates over the terms (p[i]*Polynomials.basis(p,i)) of the polynomial:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> p = Polynomial([1,2,0,4], :u)\nPolynomial(1 + 2*u + 4*u^3)\n\njulia> collect(Polynomials.monomials(p))\n4-element Vector{Any}:\n Polynomial(1)\n Polynomial(2*u)\n Polynomial(0)\n Polynomial(4*u^3)","category":"page"},{"location":"","page":"Home","title":"Home","text":"The map function for polynomials is idiosyncratic, as iteration over polynomials is over the vector of coefficients, but map will also maintain the type of the polynomial. Here we use map to smooth out the round-off error coming from the root-finding algorithm used internally when converting to the FactoredPolynomial type:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> p = Polynomial([24, -50, 35, -10, 1])\nPolynomial(24 - 50*x + 35*x^2 - 10*x^3 + x^4)\n\njulia> q = convert(FactoredPolynomial, p) # noisy form of `factor`:\nFactoredPolynomial((x - 4.0000000000000036) * (x - 2.9999999999999942) * (x - 1.0000000000000002) * (x - 2.0000000000000018))\n\njulia> map(x -> round(x, digits=10), q)\nFactoredPolynomial((x - 4.0) * (x - 2.0) * (x - 3.0) * (x - 1.0))","category":"page"},{"location":"#Relationship-between-the-T-and-P{T,X}","page":"Home","title":"Relationship between the T and P{T,X}","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The addition of a polynomial and a scalar, such as","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using Polynomials\n\njulia> p = Polynomial([1,2,3], :x)\nPolynomial(1 + 2*x + 3*x^2)\n\njulia> p + 3\nPolynomial(4 + 2*x + 3*x^2)","category":"page"},{"location":"","page":"Home","title":"Home","text":"seems natural, but in Julia, as 3 is of type Int and p of type Polynomial{Int,:x} some addition must be defined. The basic idea  is that 3 is promoted to the constant polynomial 3 with indeterminate :x as 3*one(p) and then addition of p + 3*one(p) is performed.","category":"page"},{"location":"","page":"Home","title":"Home","text":"This identification of a scalar with a constant polynomial can go both ways. If q is a constant polynomial of type Polynomial{Int, :y} then we should expect that p+q would be defined, as p plus the constant term of q. Indeed this is the case","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> q = Polynomial(3, :y)\nPolynomial(3)\n\njulia> p + q\nPolynomial(4 + 2*x + 3*x^2)","category":"page"},{"location":"","page":"Home","title":"Home","text":"If q is non-constant, such as variable(Polynomial, :y), then there would be an error due to the mismatched symbols. (The mathematical result would need a multivariate polynomial, not a univariate polynomial, as this package provides.)","category":"page"},{"location":"","page":"Home","title":"Home","text":"The same conversion is done for polynomial multiplication: constant polynomials are treated as numbers; non-constant polynomials must have their symbols match.","category":"page"},{"location":"","page":"Home","title":"Home","text":"There is an oddity – though the following two computations look the same, they are technically different:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> one(Polynomial, :x) + one(Polynomial, :y)\nPolynomial(2.0)\n\njulia> one(Polynomial, :y) + one(Polynomial, :x)\nPolynomial(2.0)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Both are constant polynomials over Int, but the first has the indeterminate :y, the second :x.","category":"page"},{"location":"","page":"Home","title":"Home","text":"This technical difference causes no issues with polynomial addition or multiplication, as there constant polynomials are treated as numbers, but can be an issue when constant polynomials are used as array elements.","category":"page"},{"location":"","page":"Home","title":"Home","text":"For arrays, the promotion of numbers to polynomials, allows natural constructions like:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> p = Polynomial([1,2],:x)\nPolynomial(1 + 2*x)\n\njulia> q = Polynomial([1,2],:y)  # non-constant polynomials with different indeterminates\nPolynomial(1 + 2*y)\n\njulia> [1 p]\n1×2 Matrix{Polynomial{Int64, :x}}:\n Polynomial(1)  Polynomial(1 + 2*x)\n\njulia> [1 one(q)]\n1×2 Matrix{Polynomial{Int64, :y}}:\n Polynomial(1)  Polynomial(1)","category":"page"},{"location":"","page":"Home","title":"Home","text":"However, as there would be an ambiguous outcome of the following","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> [one(p) one(q)]\nERROR: ArgumentError: Polynomials have different indeterminates\n[...]","category":"page"},{"location":"","page":"Home","title":"Home","text":"an error is thrown.","category":"page"},{"location":"","page":"Home","title":"Home","text":"In general, arrays with mixtures of non-constant polynomials with different indeterminates will error. By default, an error will occur when constant polynomials with different indeterminates are used as components. However, for typed arrays, conversion will allow such constructs to be used.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Using one(q) for a constant polynomial with indeterminate :y we have:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> P = typeof(p)\nPolynomial{Int64, :x}\n\njulia> P[one(p) one(q)]\n1×2 Matrix{Polynomial{Int64, :x}}:\n Polynomial(1)  Polynomial(1)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Of course, by not being explicit, there are sill gotchas. For example, we can construct this matrix without a specific types:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> [one(p), one(q)+one(p)]\n2-element Vector{Polynomial{Int64, :x}}:\n Polynomial(1)\n Polynomial(2)","category":"page"},{"location":"","page":"Home","title":"Home","text":"but not this one:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> [one(p), one(p) + one(q)]\nERROR: ArgumentError: Polynomials have different indeterminates\n[...]","category":"page"},{"location":"","page":"Home","title":"Home","text":"Also, mixing types can result in unspecific symbols, as this example shows:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> [1 p; p 1] + [1 2one(q); 3 4] # array{P{T,:x}} + array{P{T,:y}}\n2×2 Matrix{Polynomial{Int64}}:\n Polynomial(2)        Polynomial(3 + 2*x)\n Polynomial(4 + 2*x)  Polynomial(5)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Though were a non-constant polynomial with indeterminate y replacing 2one(q) above, that addition would throw an error.","category":"page"},{"location":"#Non-number-types-for-T","page":"Home","title":"Non-number types for T","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The coefficients of the polynomial may be non-number types, such as matrices or other polynomials, albeit not every operation is fully supported.","category":"page"},{"location":"","page":"Home","title":"Home","text":"For example, a polynomial with matrix coefficients, might be constructed with:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using Polynomials\n\njulia> a,b,c = [1 0;2 1], [1 0; 3 1], [1 0; 4 1]\n([1 0; 2 1], [1 0; 3 1], [1 0; 4 1])\n\njulia> p = Polynomial([a,b,c])\nPolynomial([1 0; 2 1] + [1 0; 3 1]*x + [1 0; 4 1]*x^2)\n\njulia> q = derivative(p)\nPolynomial([1 0; 3 1] + [2 0; 8 2]*x)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Various operations are available, derivative was shown above, here are the vector-space operations:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> 2p\nPolynomial([2 0; 4 2] + [2 0; 6 2]*x + [2 0; 8 2]*x^2)\n\njulia> p + q\nPolynomial([2 0; 5 2] + [3 0; 11 3]*x + [1 0; 4 1]*x^2)","category":"page"},{"location":"","page":"Home","title":"Home","text":"polynomial multiplication:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> p * q\nPolynomial([1 0; 5 1] + [3 0; 18 3]*x + [3 0; 21 3]*x^2 + [2 0; 16 2]*x^3)","category":"page"},{"location":"","page":"Home","title":"Home","text":"polynomial evaluation, here either with a scalar or a matrix:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> p(2)\n2×2 Matrix{Int64}:\n  7  0\n 24  7\n\njulia> p(b)\n2×2 Matrix{Int64}:\n  3  0\n 18  3","category":"page"},{"location":"","page":"Home","title":"Home","text":"But if the type T lacks support of some generic functions, such as zero(T) and one(T), then there may be issues. For example,  when T <: AbstractMatrix the output of p-p is an error, as the implementation assumes zero(T) is defined. For static arrays, this isn't an issue, as there is support for zero(T). Other polynomial types, such as SparsePolynomial have less support, as some specialized methods assume more of the generic interface be implemented.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Similarly, using polynomials for T is a possibility:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> a,b,c = Polynomial([1],:y), Polynomial([0,1],:y), Polynomial([0,0,1],:y)\n(Polynomial(1), Polynomial(y), Polynomial(y^2))\n\njulia> p = Polynomial([a,b,c], :x)\nPolynomial(Polynomial(1) + Polynomial(y)*x + Polynomial(y^2)*x^2)\n\njulia> q = derivative(p)\nPolynomial(Polynomial(y) + Polynomial(2*y^2)*x)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Again, much works:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> 2p\nPolynomial(Polynomial(2) + Polynomial(2*y)*x + Polynomial(2*y^2)*x^2)\n\njulia> p + q\nPolynomial(Polynomial(1 + y) + Polynomial(y + 2*y^2)*x + Polynomial(y^2)*x^2)\n\njulia> p(2)\nPolynomial(1 + 2*y + 4*y^2)\n\njulia> p(b)\nPolynomial(1 + y^2 + y^4)","category":"page"},{"location":"","page":"Home","title":"Home","text":"But much doesn't. For example, implicit promotion can fail. For example, the scalar multiplication p * b will fail,  as the methods assume this is the fallback polynomial multiplication and not the intended scalar multiplication.","category":"page"},{"location":"#Rational-functions","page":"Home","title":"Rational functions","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The package provides support for rational functions – fractions of polynomials (for most types). The construction of the basic type mirrors the construction of rational numbers.","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> P = FactoredPolynomial\nFactoredPolynomial\n\njulia> p,q = fromroots(P, [1,2,3,4]), fromroots(P, [2,2,3,5])\n(FactoredPolynomial((x - 4) * (x - 2) * (x - 3) * (x - 1)), FactoredPolynomial((x - 5) * (x - 2)² * (x - 3)))\n\njulia> pq = p // q\n((x - 4) * (x - 2) * (x - 3) * (x - 1)) // ((x - 5) * (x - 2)² * (x - 3))\n\njulia> lowest_terms(pq)\n((x - 4.0) * (x - 1.0)) // ((x - 5.0) * (x - 2.0))\n\njulia> d,r = residues(pq); r\nDict{Float64, Vector{Float64}} with 2 entries:\n  5.0 => [1.33333]\n  2.0 => [0.666667]\n\njulia> x = variable(p);\n\njulia> for (λ, rs) ∈ r # reconstruct p/q from output of `residues`\n           for (i,rᵢ) ∈ enumerate(rs)\n               d += rᵢ//(x-λ)^i\n           end\n       end\n\njulia> d\n((x - 4.0) * (x - 1.0000000000000002)) // ((x - 5.0) * (x - 2.0))","category":"page"},{"location":"","page":"Home","title":"Home","text":"A basic plot recipe is provided.","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Plots, Polynomials\nP = FactoredPolynomial\np,q = fromroots(P, [1,2,3]), fromroots(P, [2,3,3,0])\nplot(p//q)\nsavefig(\"rational_function.svg\"); nothing # hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: )","category":"page"},{"location":"#Related-Packages","page":"Home","title":"Related Packages","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"StaticUnivariatePolynomials.jl Fixed-size univariate polynomials backed by a Tuple\nMultiPoly.jl for sparse multivariate polynomials\nDynamicPolynomals.jl Multivariate polynomials implementation of commutative and non-commutative variables\nMultivariatePolynomials.jl for multivariate polynomials and moments of commutative or non-commutative variables\nPolynomialRings.jl A library for arithmetic and algebra with multi-variable polynomials.\nAbstractAlgebra.jl, Nemo.jl for generic polynomial rings, matrix spaces, fraction fields, residue rings, power series, Hecke.jl for algebraic number theory.\nLaurentPolynomials.jl A package for Laurent polynomials.\nCommutativeAlgebra.jl the start of a computer algebra system specialized to discrete calculations with support for polynomials.\nPolynomialRoots.jl for a fast complex polynomial root finder. For larger degree problems, also FastPolynomialRoots and AMRVW.\nSpecialPolynomials.jl A package providing various polynomial types beyond the standard basis polynomials in Polynomials.jl. Includes interpolating polynomials, Bernstein polynomials, and classical orthogonal polynomials.\nClassicalOrthogonalPolynomials.jl A Julia package for classical orthogonal polynomials and expansions. Includes chebyshevt, chebyshevu, legendrep, jacobip, ultrasphericalc, hermiteh, and laguerrel. The same repository includes FastGaussQuadrature.jl, FastTransforms.jl, and the ApproxFun packages.","category":"page"},{"location":"#Contributing","page":"Home","title":"Contributing","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you are interested in this project, feel free to open an issue or pull request! In general, any changes must be thoroughly tested, allow deprecation, and not deviate too far from the common interface. All PR's must have an updated project version, as well, to keep the continuous delivery cycle up-to-date.","category":"page"},{"location":"polynomials/chebyshev/#Chebyshev-Polynomials","page":"Chebyshev","title":"Chebyshev Polynomials","text":"","category":"section"},{"location":"polynomials/chebyshev/","page":"Chebyshev","title":"Chebyshev","text":"DocTestSetup = quote\n  using Polynomials\nend","category":"page"},{"location":"polynomials/chebyshev/","page":"Chebyshev","title":"Chebyshev","text":"The Chebyshev polynomials are two sequences of polynomials, T_n and U_n. The Chebyshev polynomials of the first kind, T_n, can be defined by the recurrence relation:","category":"page"},{"location":"polynomials/chebyshev/","page":"Chebyshev","title":"Chebyshev","text":"T_0(x)=1 T_1(x)=x","category":"page"},{"location":"polynomials/chebyshev/","page":"Chebyshev","title":"Chebyshev","text":"T_n+1(x) = 2xT_n(x)-T_n-1(x)","category":"page"},{"location":"polynomials/chebyshev/","page":"Chebyshev","title":"Chebyshev","text":"The Chebyshev polynomioals of the second kind, U_n(x), can be defined by","category":"page"},{"location":"polynomials/chebyshev/","page":"Chebyshev","title":"Chebyshev","text":"U_0(x)=1 U_1(x)=2x","category":"page"},{"location":"polynomials/chebyshev/","page":"Chebyshev","title":"Chebyshev","text":"U_n+1(x) = 2xU_n(x) - U_n-1(x)","category":"page"},{"location":"polynomials/chebyshev/","page":"Chebyshev","title":"Chebyshev","text":"Both T_n and U_n have degree n, and any polynomial of degree n may be uniquely written as a linear combination of the polynomials T_0, T_1, ..., T_n (similarly with U_n).","category":"page"},{"location":"polynomials/chebyshev/#First-Kind","page":"Chebyshev","title":"First Kind","text":"","category":"section"},{"location":"polynomials/chebyshev/","page":"Chebyshev","title":"Chebyshev","text":"ChebyshevT","category":"page"},{"location":"polynomials/chebyshev/#Polynomials.ChebyshevT","page":"Chebyshev","title":"Polynomials.ChebyshevT","text":"ChebyshevT{T, X}(coeffs::AbstractVector)\n\nChebyshev polynomial of the first kind.\n\nConstruct a polynomial from its coefficients coeffs, lowest order first, optionally in terms of the given variable var, which can be a character, symbol, or string.\n\nnote: Note\nChebyshevT is not axis-aware, and it treats coeffs simply as a list of coefficients with the first index always corresponding to the coefficient of T_0(x).\n\nExamples\n\njulia> using Polynomials\n\njulia> p = ChebyshevT([1, 0, 3, 4])\nChebyshevT(1⋅T_0(x) + 3⋅T_2(x) + 4⋅T_3(x))\n\njulia> ChebyshevT([1, 2, 3, 0], :s)\nChebyshevT(1⋅T_0(s) + 2⋅T_1(s) + 3⋅T_2(s))\n\njulia> one(ChebyshevT)\nChebyshevT(1.0⋅T_0(x))\n\njulia> p(0.5)\n-4.5\n\njulia> Polynomials.evalpoly(5.0, p, false) # bypasses the domain check done in p(5.0)\n2088.0\n\nThe latter shows how to evaluate a ChebyshevT polynomial outside of its domain, which is [-1,1]. (For newer versions of Julia, evalpoly is an exported function from Base with methods extended in this package, so the module qualification is unnecessary.\n\nnote: Note\nThe Chebyshev polynomials are also implemented in ApproxFun, ClassicalOrthogonalPolynomials.jl, FastTransforms.jl, and SpecialPolynomials.jl.\n\n\n\n\n\n","category":"type"},{"location":"polynomials/chebyshev/","page":"Chebyshev","title":"Chebyshev","text":"The ChebyshevT type holds coefficients representing the polynomial a_0 T_0 + a_1 T_1 +  + a_n T_n.","category":"page"},{"location":"polynomials/chebyshev/","page":"Chebyshev","title":"Chebyshev","text":"For example, the basis polynomial T_4 can be represented with ChebyshevT([0,0,0,0,1]).","category":"page"},{"location":"polynomials/chebyshev/#Conversion","page":"Chebyshev","title":"Conversion","text":"","category":"section"},{"location":"polynomials/chebyshev/","page":"Chebyshev","title":"Chebyshev","text":"ChebyshevT can be converted to Polynomial and vice-versa.","category":"page"},{"location":"polynomials/chebyshev/","page":"Chebyshev","title":"Chebyshev","text":"julia> c = ChebyshevT([1, 0, 3, 4])\nChebyshevT(1⋅T_0(x) + 3⋅T_2(x) + 4⋅T_3(x))\n\n\njulia> p = convert(Polynomial, c)\nPolynomial(-2 - 12*x + 6*x^2 + 16*x^3)\n\njulia> convert(ChebyshevT, p)\nChebyshevT(1.0⋅T_0(x) + 3.0⋅T_2(x) + 4.0⋅T_3(x))","category":"page"}]
}
