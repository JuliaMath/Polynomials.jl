var documenterSearchIndex = {"docs":
[{"location":"extending/#Extending-Polynomials","page":"Extending","title":"Extending Polynomials","text":"","category":"section"},{"location":"extending/","page":"Extending","title":"Extending","text":"The AbstractUnivariatePolynomial type was made to be extended.","category":"page"},{"location":"extending/","page":"Extending","title":"Extending","text":"A polynomial's  coefficients  are  relative to some basis. The Polynomial type relates coefficients  [a0, a1,  ..., an], say,  to the  polynomial  a_0 +  a_1cdot x + a_2cdot x^2  + cdots +  a_ncdot x^n,  through the standard  basis  1  x  x^2  x^n.  New polynomial  types typically represent the polynomial through a different  basis. For example,  CheyshevT uses a basis  T_0=1 T_1=x  T_2=2x^2-1  cdots  T_n  =  2xT_n-1 - T_n-2.  For this type  the  coefficients  [a0,a1,...,an] are associated with  the polynomial  `a0\\cdot T_0  + a_1 \\cdot T_1 +  \\cdots  +  a_n\\cdot T_n.","category":"page"},{"location":"extending/","page":"Extending","title":"Extending","text":"A polynomial type consists of a container type (with parent type AbstractUnivariatePolynomial) and a basis type (with parent type AbstractBasis). There a several different storage types implemented.","category":"page"},{"location":"extending/","page":"Extending","title":"Extending","text":"To implement a new polynomial type, P, the following methods should be implemented:","category":"page"},{"location":"extending/","page":"Extending","title":"Extending","text":"Function Required Notes\nA container type x Usually selected from an available one.\nA basis type x \nvariable  Convenience to find the monomial x in the new basis.\nBase.evalpoly(x, p::P) x To evaluate the polynomial at x\n*(::P, ::P)  Multiplication of polynomials\nconvert(::P, p::Polynomial) Defaults to polynomial evaluation. Can be used to define * by round trip through Polynomial type \nconvert(::Polynomial, p)  Defaults to polynomial evaluation, which uses evalpoly, variable, *\nscalar_add(c::S, ::P)  Scalar addition. Default requires one to be defined.\none x Convenience to find the constant 1 in the new basis.\nmap(f, p) x Used to define scalar multiplication\ndivrem  Required for gcd\nvander  Required for fit\ncompanion  Required for roots\nPolynomials.domain  Should return a Polynomials.Interval instance","category":"page"},{"location":"extending/","page":"Extending","title":"Extending","text":"As always, if the default implementation does not work or there are more efficient ways of implementing, feel free to overwrite functions from common.jl for your type.","category":"page"},{"location":"extending/","page":"Extending","title":"Extending","text":"The general idea is the container type should provide the vector operations of polynomial addition, subtraction, and scalar multiplication. The latter is generically implemented through a map(f,p) method. The second example illustrates, though it isn't expected that container types will need being defined by users of this package.","category":"page"},{"location":"extending/","page":"Extending","title":"Extending","text":"The basis type directs dispatch for other operations and allows definitions for one and variable. An evalpoly method may be defined for a given basis type, though specializations based on the container may be desirable.","category":"page"},{"location":"extending/","page":"Extending","title":"Extending","text":"Methods like * will typically need to consider both the underlying container type and the basis, though if convert methods are defined, the defaults can be utilized as converting to the Polynomial type, performing the operation, then converting back is possible, though likely not as efficient.","category":"page"},{"location":"extending/","page":"Extending","title":"Extending","text":"note: Note\nMost promotion rules will coerce towards the Polynomial type, so not all methods have to be implemented if you provide a conversion function.","category":"page"},{"location":"extending/#A-new-basis-type","page":"Extending","title":"A new basis type","text":"","category":"section"},{"location":"extending/","page":"Extending","title":"Extending","text":"The generalized Laguerre polynomials are orthogonal polynomials parameterized  by alpha and defined recursively by","category":"page"},{"location":"extending/","page":"Extending","title":"Extending","text":"beginalign*\nL^alpha_1(x) = 1\nL^alpha_2(x) = 1 + alpha - x\nL^alpha_n+1(x) = frac2n+1+alpha -xn+1 L^alpha_n(x) - fracn+alphan+1 L^alpha_n-1(x)\n= (A_nx +B_n) cdot L^alpha_n(x) - C_n cdot L^alpha_n-1(x)\nendalign*","category":"page"},{"location":"extending/","page":"Extending","title":"Extending","text":"There are other characterizations available. The three-point recursion, described by A,B, and C is used below for evaluation.","category":"page"},{"location":"extending/","page":"Extending","title":"Extending","text":"We show how to define a new basis type, LaguerreBasis, leveraging one of the existing container types. In this example our basis type has a parameter. The ChebyshevT type, gives a related example of how this task can be implemented.","category":"page"},{"location":"extending/","page":"Extending","title":"Extending","text":"First we load the package and import a few non-exported functions:","category":"page"},{"location":"extending/","page":"Extending","title":"Extending","text":"julia> using Polynomials;\n\njulia> import Polynomials: AbstractUnivariatePolynomial, AbstractBasis, MutableDensePolynomial;","category":"page"},{"location":"extending/","page":"Extending","title":"Extending","text":"We define the basis with:","category":"page"},{"location":"extending/","page":"Extending","title":"Extending","text":"julia> struct LaguerreBasis{alpha} <: AbstractBasis end\n\njulia> Polynomials.basis_symbol(::Type{<:AbstractUnivariatePolynomial{LaguerreBasis{α},T,X}}) where {α,T,X} =\n           \"L^$(α)\"","category":"page"},{"location":"extending/","page":"Extending","title":"Extending","text":"We added a method to basis_symbol to show this basis. The display of the basis symbol has a poor default. The method above requires the full type, as the indeterminate, X, may be part of the desired output.  More generally, Polynomials.printbasis can have methods added to adjust for different display types.","category":"page"},{"location":"extending/","page":"Extending","title":"Extending","text":"Polynomial types can be initiated through specifying a storage type and a basis type, say:","category":"page"},{"location":"extending/","page":"Extending","title":"Extending","text":"julia> P = MutableDensePolynomial{LaguerreBasis{0}}\nMutableDensePolynomial{LaguerreBasis{0}}","category":"page"},{"location":"extending/","page":"Extending","title":"Extending","text":"Instances can now be created:","category":"page"},{"location":"extending/","page":"Extending","title":"Extending","text":"julia> p = P([1,2,3])\nMutableDensePolynomial(1L^0_0 + 2*L^0_1 + 3*L^0_2)","category":"page"},{"location":"extending/","page":"Extending","title":"Extending","text":"Or using other storage types:","category":"page"},{"location":"extending/","page":"Extending","title":"Extending","text":"julia> Polynomials.ImmutableDensePolynomial{LaguerreBasis{1}}((1,2,3))\nPolynomials.ImmutableDensePolynomial(1L^1_0 + 2*L^1_1 + 3*L^1_2)","category":"page"},{"location":"extending/","page":"Extending","title":"Extending","text":"All polynomial types have vector addition and scalar multiplication defined, as these are basis independent:","category":"page"},{"location":"extending/","page":"Extending","title":"Extending","text":"julia> q = P([1,2])\nMutableDensePolynomial(1L^0_0 + 2*L^0_1)\n\njulia> p + q\nMutableDensePolynomial(2L^0_0 + 4*L^0_1 + 3*L^0_2)\n\njulia> 2p\nMutableDensePolynomial(2L^0_0 + 4*L^0_1 + 6*L^0_2)","category":"page"},{"location":"extending/","page":"Extending","title":"Extending","text":"For a new basis, there are no default methods for polynomial evaluation and polynomial multiplication; and no defaults for one (used by default for scalar addition), and variable (used by default in conversion).","category":"page"},{"location":"extending/","page":"Extending","title":"Extending","text":"For the Laguerre Polynomials, Clenshaw recursion can be used for evaluation.","category":"page"},{"location":"extending/","page":"Extending","title":"Extending","text":"julia> function ABC(::Type{LaguerreBasis{α}}, n) where {α}\n           o = one(α)\n           d = n + o\n           (A=-o/d, B=(2n + o + α)/d, C=(n+α)/d)\n       end\nABC (generic function with 1 method)","category":"page"},{"location":"extending/","page":"Extending","title":"Extending","text":"julia> function clenshaw_eval(p::P, x::S) where {α, Bᵅ<: LaguerreBasis{α}, T, P<:AbstractUnivariatePolynomial{Bᵅ,T}, S}\n           d = degree(p)\n           R = typeof(((one(α) * one(T)) * one(S)) / 1)\n           p₀ = one(R)\n           d == -1 && return zero(R)\n           d == 0 && return p[0] * one(R)\n           Δ0 = p[d-1]\n           Δ1 = p[d]\n           @inbounds for i in (d - 1):-1:1\n               A,B,C = ABC(Bᵅ, i)\n               Δ0, Δ1 =\n                   p[i] - Δ1 * C, Δ0 + Δ1 * muladd(x, A, B)\n           end\n           A,B,C = ABC(Bᵅ, 0)\n           p₁ = muladd(x, A, B) * p₀\n           return Δ0 * p₀ + Δ1 * p₁\n       end\nclenshaw_eval (generic function with 1 method)","category":"page"},{"location":"extending/","page":"Extending","title":"Extending","text":"Internally, evalpoly is called so we forward that method.","category":"page"},{"location":"extending/","page":"Extending","title":"Extending","text":"julia> Polynomials.evalpoly(x, p::P) where {P<:AbstractUnivariatePolynomial{<:LaguerreBasis}} =\n               clenshaw_eval(p, x)","category":"page"},{"location":"extending/","page":"Extending","title":"Extending","text":"We test this out by passing in the variable x in the standard basis:","category":"page"},{"location":"extending/","page":"Extending","title":"Extending","text":"julia> p = P([0,0,1])\nMutableDensePolynomial(L^0_2)\n\njulia> x = variable(Polynomial)\nPolynomial(1.0*x)\n\njulia> p(x)\nPolynomial(1.0 - 2.0*x + 0.5*x^2)","category":"page"},{"location":"extending/","page":"Extending","title":"Extending","text":"This shows evaluation works and also that conversion to the Polynomial type is available through polynomial evaluation. This is used by default by convert, so we immediately have other convert methods available:","category":"page"},{"location":"extending/","page":"Extending","title":"Extending","text":"julia> convert(ChebyshevT, p)\nChebyshevT(1.25⋅T_0(x) - 2.0⋅T_1(x) + 0.25⋅T_2(x))","category":"page"},{"location":"extending/","page":"Extending","title":"Extending","text":"Or, using some extra annotations to have rational arithmetic used, we can compare to easily found representations in the standard basis:","category":"page"},{"location":"extending/","page":"Extending","title":"Extending","text":"julia> q = Polynomials.basis(MutableDensePolynomial{LaguerreBasis{0//1}, Int}, 5)\nMutableDensePolynomial(L^0//1_5)\n\njulia> x = variable(Polynomial{Int})\nPolynomial(x)\n\njulia> q(x)\nPolynomial(1//1 - 5//1*x + 5//1*x^2 - 5//3*x^3 + 5//24*x^4 - 1//120*x^5)","category":"page"},{"location":"extending/","page":"Extending","title":"Extending","text":"The values of one and variable are straightforward to define, as L_0=1 and L_1=1 - x or x = L_0 - L_1","category":"page"},{"location":"extending/","page":"Extending","title":"Extending","text":"julia> Polynomials.one(::Type{P}) where {B<:LaguerreBasis,T,X,P<:AbstractUnivariatePolynomial{B,T,X}} =\n           P([one(T)])\n\njulia> Polynomials.variable(::Type{P}) where {B<:LaguerreBasis,T,X,P<:AbstractUnivariatePolynomial{B,T,X}} =\n           P([one(T), -one(T)])","category":"page"},{"location":"extending/","page":"Extending","title":"Extending","text":"To see this is correct, we have:","category":"page"},{"location":"extending/","page":"Extending","title":"Extending","text":"julia> variable(P)(x) == x\ntrue","category":"page"},{"location":"extending/","page":"Extending","title":"Extending","text":"Scalar addition defaults to a call to one(p), so this is now defined:","category":"page"},{"location":"extending/","page":"Extending","title":"Extending","text":"julia> 2 + p\nMutableDensePolynomial(2L^0_0 + L^0_2)","category":"page"},{"location":"extending/","page":"Extending","title":"Extending","text":"Often it is more performant to implement a specific method for scalar_add. Here we utilize the fact that L_0 = 1 to manipulate the coefficients. Below we specialize to a container type:","category":"page"},{"location":"extending/","page":"Extending","title":"Extending","text":"julia> function Polynomials.scalar_add(c::S, p::P) where {B<:LaguerreBasis,T,X,\n                                                          P<:MutableDensePolynomial{B,T,X},S}\n           R = promote_type(T,S)\n           iszero(p) && return MutableDensePolynomial{B,R,X}(c)\n           cs = convert(Vector{R}, copy(p.coeffs))\n           cs[1] += c\n           MutableDensePolynomial{B,R,X}(cs)\n       end\n\njulia> p + 3\nMutableDensePolynomial(3L^0_0 + L^0_2)","category":"page"},{"location":"extending/","page":"Extending","title":"Extending","text":"Multiplication defaults to a code path where the two polynomials are promoted to a common type and then multiplied. Here we implement polynomial multiplication through conversion to the polynomial type. The direct formula could be implemented, but that isn't so illustrative for this example. See the SpecialPolynomials package for an implementation.","category":"page"},{"location":"extending/","page":"Extending","title":"Extending","text":"julia> function Base.:*(p::MutableDensePolynomial{B,T,X},\n                        q::MutableDensePolynomial{B,S,X}) where {B<:LaguerreBasis, T,S,X}\n           x = variable(Polynomial{T,X})\n           p(x) * q(x)\n       end","category":"page"},{"location":"extending/","page":"Extending","title":"Extending","text":"Were it defined, a convert method from Polynomial to the LaguerreBasis could be used to implement multiplication, as we have defined a variable method.","category":"page"},{"location":"extending/#A-new-container-type","page":"Extending","title":"A new container type","text":"","category":"section"},{"location":"extending/","page":"Extending","title":"Extending","text":"This example shows how to make a new container type, though this should be unnecessary, given the current variety, there may be gains to be had (e.g. an immutable, sparse type?) In this case, we offer a minimal example where the polynomial type aliases the vector defining the coefficients is created.  For other bases, more methods may be necessary to define (again, refer to ChebyshevT for an example).","category":"page"},{"location":"extending/","page":"Extending","title":"Extending","text":"We have two constructor methods. The first is the typical code path. It makes a copy of the coefficients and then wraps those within the polynomial container type. For performance reasons, generically it is helpful to pass in a flag to indicate no copying or checking of the input is needed (Val{false}). This is used by some inherited methods when we specialize to the StandardBasis type. Generically, a container type may accept an offset, though this type won't; a 0-based vector is implicit.","category":"page"},{"location":"extending/","page":"Extending","title":"Extending","text":"julia> using Polynomials\n\njulia> struct AliasPolynomialType{B,T,X} <: Polynomials.AbstractDenseUnivariatePolynomial{B, T, X}\n           coeffs::Vector{T}\n           function AliasPolynomialType{B, T, X}(coeffs::AbstractVector{S}, o::Int=0) where {B, T, S, X}\n               new{B,T,Symbol(X)}(convert(Vector{T}, copy(coeffs)))\n           end\n           function AliasPolynomialType{B, T, X}(::Val{false}, coeffs::AbstractVector{S}, o::Int=0) where {B, T, S, X}\n               new{B,T,Symbol(X)}(convert(Vector{T}, coeffs))\n           end\n       end\n\njulia> Polynomials.@poly_register AliasPolynomialType","category":"page"},{"location":"extending/","page":"Extending","title":"Extending","text":"The call to @poly_register adds many different means to construct polynomials of this type along with some other default methods.","category":"page"},{"location":"extending/","page":"Extending","title":"Extending","text":"A few methods need defining to get indexing to work:","category":"page"},{"location":"extending/","page":"Extending","title":"Extending","text":"julia> Base.firstindex(p::AliasPolynomialType) = 0\n\njulia> Base.lastindex(p::AliasPolynomialType) = length(p.coeffs) - 1\n","category":"page"},{"location":"extending/","page":"Extending","title":"Extending","text":"julia> Polynomials.constructorof(::Type{<:AliasPolynomialType{B}}) where {B} = AliasPolynomialType{B}\n","category":"page"},{"location":"extending/","page":"Extending","title":"Extending","text":"We need to add in the vector-space operations:","category":"page"},{"location":"extending/","page":"Extending","title":"Extending","text":"julia> function Base.:+(p::AliasPolynomialType{B,T,X}, q::AliasPolynomialType{B,S,X}) where {B,S,T,X}\n           R = promote_type(T,S)\n           n = maximum(degree, (p,q))\n           cs = [p[i] + q[i] for i in 0:n]\n           AliasPolynomialType{B,R,X}(Val(false), cs)  # save a copy\n       end\n\njulia> function Base.:-(p::AliasPolynomialType{B,T,X}, q::AliasPolynomialType{B,S,X}) where {B,S,T,X}\n           R = promote_type(T,S)\n           n = maximum(degree, (p,q))\n           cs = [p[i] - q[i] for i in 0:n]\n           AliasPolynomialType{B,R,X}(Val(false), cs)\n       end\n\njulia> function Base.map(fn, p::P) where {B,T,X,P<:AliasPolynomialType{B,T,X}}\n           cs = map(fn, p.coeffs)\n           R = eltype(cs)\n           AliasPolynomialType{B,R,X}(Val(false), cs)\n       end\n","category":"page"},{"location":"extending/","page":"Extending","title":"Extending","text":"A type and a basis defines a polynomial type. This example uses the  StandardBasis basis type and consequently inherits the methods mentioned above that otherwise would need implementing.","category":"page"},{"location":"extending/","page":"Extending","title":"Extending","text":"julia> AliasPolynomial = AliasPolynomialType{Polynomials.StandardBasis};\n","category":"page"},{"location":"extending/","page":"Extending","title":"Extending","text":"To see this new polynomial type in action, we have:","category":"page"},{"location":"extending/","page":"Extending","title":"Extending","text":"julia> xs = [1,2,3,4];\n\njulia> p = AliasPolynomial(xs)\nAliasPolynomialType(1 + 2*x + 3*x^2 + 4*x^3)\n\njulia> q = AliasPolynomial(1.0, :y)\nAliasPolynomialType(1.0)\n\njulia> 2p - q\nAliasPolynomialType(3.0 + 4.0*x + 6.0*x^2 + 8.0*x^3)\n\njulia> (derivative ∘ integrate)(p) == p\ntrue\n\njulia> p(3)\n142","category":"page"},{"location":"extending/","page":"Extending","title":"Extending","text":"The default for polynomial multiplication is to call * for two instances of the type with the same variable, and possibly different element types. For standard basis types, we can add this method:","category":"page"},{"location":"extending/","page":"Extending","title":"Extending","text":"julia> Base.:*(p::AliasPolynomialType{T,X}, q::AliasPolynomialType{S,X}) where {T,S,X} = Polynomials._standard_basis_multiplication(p,q)\n\njulia> p * p\nAliasPolynomialType(1 + 4*x + 10*x^2 + 20*x^3 + 25*x^4 + 24*x^5 + 16*x^6)","category":"page"},{"location":"extending/","page":"Extending","title":"Extending","text":"For the Polynomial type, the default on operations is to copy the array. For this type, it might seem reasonable – to avoid allocations – to update the coefficients in place for scalar addition and scalar multiplication.","category":"page"},{"location":"extending/","page":"Extending","title":"Extending","text":"Scalar addition, p+c, defaults to p + c*one(p), or polynomial addition, which is not inplace without additional work. As such, we create a new method and an infix operator","category":"page"},{"location":"extending/","page":"Extending","title":"Extending","text":"julia> function scalar_add!(c::T, p::AliasPolynomial{T}) where {T}\n           p.coeffs[1] += c\n           p\n       end;\n\njulia> p::AliasPolynomial +ₛ c::Number = scalar_add!(c, p);\n\njulia> c::Number +ₛ p::AliasPolynomial = scalar_add!(c, p);","category":"page"},{"location":"extending/","page":"Extending","title":"Extending","text":"The viewpoint that a polynomial represents a vector of coefficients leads to an expectation that vector operations should match when possible. Scalar multiplication is a vector operation, so it seems reasonable to override the broadcast machinery to implement an in place operation (e.g. p .*= 2). By default, the polynomial types are not broadcastable over their coefficients. We would need to make a change there and modify the copyto! function:","category":"page"},{"location":"extending/","page":"Extending","title":"Extending","text":"julia> Base.broadcastable(p::AliasPolynomial) = p.coeffs;\n\njulia> Base.ndims(::Type{<:AliasPolynomial}) = 1\n\njulia> Base.copyto!(p::AliasPolynomial, x) = (copyto!(p.coeffs, x); chop!(p));\n\njulia> p\nAliasPolynomialType(1 + 2*x + 3*x^2 + 4*x^3)\n\njulia> p .*= 2\nAliasPolynomialType(2 + 4*x + 6*x^2 + 8*x^3)\n\njulia> p ./= 2\nAliasPolynomialType(1 + 2*x + 3*x^2 + 4*x^3)","category":"page"},{"location":"extending/","page":"Extending","title":"Extending","text":"Trying to divide again would throw an error, as the result would not fit with the integer type of p.","category":"page"},{"location":"extending/","page":"Extending","title":"Extending","text":"Now p is treated as the vector p.coeffs, as regards broadcasting, so some things may be surprising, for example this expression returns a vector, not a polynomial:","category":"page"},{"location":"extending/","page":"Extending","title":"Extending","text":"julia> p .+ 2\n4-element Vector{Int64}:\n 3\n 4\n 5\n 6","category":"page"},{"location":"extending/","page":"Extending","title":"Extending","text":"The unexported Polynomials.PnPolynomial polynomial type implements much of the above.","category":"page"},{"location":"extending/","page":"Extending","title":"Extending","text":"","category":"page"},{"location":"extending/#Polynomials.AbstractUnivariatePolynomial","page":"Extending","title":"Polynomials.AbstractUnivariatePolynomial","text":"AbstractUnivariatePolynomial{B,T,X} <: AbstractPolynomial{T,X}\nAbstractDenseUnivariatePolynomial{B,T,X} <: AbstractUnivariatePolynomial{B,T,X}\nAbstractLaurentUnivariatePolynomial{B,T,X} <: AbstractUnivariatePolynomial{B,T,X}\n\nAbstract container types for polynomials with an explicit basis, B. AbstractDenseUnivariatePolynomial is for 0-based polynomials; AbstractLaurentUnivariatePolynomial is for polynomials with possibly negative powers of the indeterminate.\n\n\n\n\n\n","category":"type"},{"location":"extending/#Polynomials.AbstractBasis","page":"Extending","title":"Polynomials.AbstractBasis","text":"AbstractBasis\n\nAbstract type for specifying a polynomial basis.\n\n\n\n\n\n","category":"type"},{"location":"polynomials/polynomial/#Polynomial","page":"Polynomial","title":"Polynomial","text":"","category":"section"},{"location":"polynomials/polynomial/","page":"Polynomial","title":"Polynomial","text":"Polynomial types using the standard basis.","category":"page"},{"location":"polynomials/polynomial/#Polynomial-2","page":"Polynomial","title":"Polynomial","text":"","category":"section"},{"location":"polynomials/polynomial/#Polynomials.Polynomial","page":"Polynomial","title":"Polynomials.Polynomial","text":"Polynomial{T, X}(coeffs::AbstractVector{T}, [var = :x])\n\nConstruct a polynomial from its coefficients coeffs, lowest order first, optionally in terms of the given variable var which may be a character, symbol, or a string.\n\nIf p = a_n x^n + ldots + a_2 x^2 + a_1 x + a_0, we construct this through Polynomial([a_0, a_1, ..., a_n]).\n\nThe usual arithmetic operators are overloaded to work with polynomials as well as with combinations of polynomials and scalars. However, operations involving two polynomials of different variables causes an error except those involving a constant polynomial.\n\nnote: Note\nPolynomial is not axis-aware, and it treats coeffs simply as a list of coefficients with the first index always corresponding to the constant term. In order to use the axis of coeffs as exponents, consider using a LaurentPolynomial or possibly a SparsePolynomial.\n\nExamples\n\njulia> using Polynomials\n\njulia> Polynomial([1, 0, 3, 4])\nPolynomial(1 + 3*x^2 + 4*x^3)\n\njulia> Polynomial([1, 2, 3], :s)\nPolynomial(1 + 2*s + 3*s^2)\n\njulia> one(Polynomial)\nPolynomial(1.0)\n\n\n\n\n\n","category":"type"},{"location":"polynomials/polynomial/#Immutable-Polynomial","page":"Polynomial","title":"Immutable Polynomial","text":"","category":"section"},{"location":"polynomials/polynomial/#Polynomials.ImmutablePolynomial","page":"Polynomial","title":"Polynomials.ImmutablePolynomial","text":"ImmutablePolynomial{T, X, N}(coeffs)\n\nConstruct an immutable (static) polynomial from its coefficients a₀, a₁, …, aₙ, lowest order first, optionally in terms of the given variable x where x can be a character, symbol, or string.\n\nIf p = a_n x^n + ldots + a_2 x^2 + a_1 x + a_0, we construct this through ImmutablePolynomial((a_0, a_1, ..., a_n)) (assuming a_n ≠ 0). As well, a vector or number can be used for construction.\n\nThe usual arithmetic operators are overloaded to work with polynomials as well as with combinations of polynomials and scalars. However, operations involving two non-constant polynomials of different variables causes an error. Unlike other polynomials, setindex! is not defined for ImmutablePolynomials.\n\nAs the degree of the polynomial (+1) is a compile-time constant, several performance improvements are possible. For example, immutable polynomials can take advantage of faster polynomial evaluation provided by evalpoly from Julia 1.4; similar methods are also used for addition and multiplication.\n\nHowever, as the degree is included in the type, promotion between immutable polynomials can not promote to a common type. As such, they are precluded from use in rational functions.\n\nnote: Note\nImmutablePolynomial is not axis-aware, and it treats coeffs simply as a list of coefficients with the first index always corresponding to the constant term.\n\nExamples\n\njulia> using Polynomials\n\njulia> ImmutablePolynomial((1, 0, 3, 4))\nImmutablePolynomial(1 + 3*x^2 + 4*x^3)\n\njulia> ImmutablePolynomial((1, 2, 3), :s)\nImmutablePolynomial(1 + 2*s + 3*s^2)\n\njulia> one(ImmutablePolynomial)\nImmutablePolynomial(1.0)\n\nnote: Note\nThis was modeled after StaticUnivariatePolynomials by @tkoolen.\n\n\n\n\n\n","category":"type"},{"location":"polynomials/polynomial/#Sparse-Polynomial","page":"Polynomial","title":"Sparse Polynomial","text":"","category":"section"},{"location":"polynomials/polynomial/#Polynomials.SparsePolynomial","page":"Polynomial","title":"Polynomials.SparsePolynomial","text":"SparsePolynomial{T, X}(coeffs::Dict{Int,T})\n\nPolynomials in the standard basis backed by a dictionary holding the non-zero coefficients. For polynomials of high degree, this might be advantageous.\n\nExamples:\n\njulia> using Polynomials\n\njulia> P = SparsePolynomial;\n\njulia> p, q = P([1,2,3]), P([4,3,2,1])\n(SparsePolynomial(1 + 2*x + 3*x^2), SparsePolynomial(4 + 3*x + 2*x^2 + x^3))\n\njulia> p + q\nSparsePolynomial(5 + 5*x + 5*x^2 + x^3)\n\njulia> p * q\nSparsePolynomial(4 + 11*x + 20*x^2 + 14*x^3 + 8*x^4 + 3*x^5)\n\njulia> p + 1\nSparsePolynomial(2 + 2*x + 3*x^2)\n\njulia> q * 2\nSparsePolynomial(8 + 6*x + 4*x^2 + 2*x^3)\n\njulia> p = Polynomials.basis(P, 10^9) - Polynomials.basis(P,0) # also P(Dict(0=>-1, 10^9=>1))\nSparsePolynomial(-1.0 + 1.0*x^1000000000)\n\njulia> p(1)\n0.0\n\nnote: Note\nSparsePolynomial is an alias for MutableSparsePolynomial{StandardBasis}.\n\n\n\n\n\n","category":"type"},{"location":"polynomials/polynomial/#Laurent-Polynomial","page":"Polynomial","title":"Laurent Polynomial","text":"","category":"section"},{"location":"polynomials/polynomial/#Polynomials.LaurentPolynomial","page":"Polynomial","title":"Polynomials.LaurentPolynomial","text":"LaurentPolynomial{T,X}(coeffs::AbstractVector, [m::Integer = 0], [var = :x])\n\nA Laurent polynomial is of the form a_{m}x^m + ... + a_{n}x^n where m,n are  integers (not necessarily positive) with m <= n.\n\nThe coeffs specify a_{m}, a_{m-1}, ..., a_{n}. The argument m represents the lowest exponent of the variable in the series, and is taken to be zero by default.\n\nLaurent polynomials and standard basis polynomials promote to  Laurent polynomials. Laurent polynomials may be  converted to a standard basis  polynomial when m >= 0,\n\nIntegration will fail if there is a x⁻¹ term in the polynomial.\n\nnote: Note\nLaurentPolynomial is axis-aware, unlike the other polynomial types in this package.\n\nExamples:\n\njulia> using Polynomials\n\njulia> P = LaurentPolynomial;\n\njulia> p = P([1,1,1],  -1)\nLaurentPolynomial(x⁻¹ + 1 + x)\n\njulia> q = P([1,1,1])\nLaurentPolynomial(1 + x + x²)\n\njulia> pp = Polynomial([1,1,1])\nPolynomial(1 + x + x^2)\n\njulia> p + q\nLaurentPolynomial(x⁻¹ + 2 + 2*x + x²)\n\njulia> p * q\nLaurentPolynomial(x⁻¹ + 2 + 3*x + 2*x² + x³)\n\njulia> p * pp\nLaurentPolynomial(x⁻¹ + 2 + 3*x + 2*x² + x³)\n\njulia> pp - q\nLaurentPolynomial(0)\n\njulia> derivative(p)\nLaurentPolynomial(-x⁻² + 1)\n\njulia> integrate(q)\nLaurentPolynomial(1.0*x + 0.5*x² + 0.3333333333333333*x³)\n\njulia> integrate(p)  # x⁻¹  term is an issue\nERROR: ArgumentError: Can't integrate Laurent polynomial with  `x⁻¹` term\n[...]\n\njulia> integrate(P([1,1,1], -5))\nLaurentPolynomial(-0.25*x⁻⁴ - 0.3333333333333333*x⁻³ - 0.5*x⁻²)\n\njulia> x⁻¹ = inv(variable(LaurentPolynomial)) # `inv` defined on monomials\nLaurentPolynomial(1.0*x⁻¹)\n\njulia> p = Polynomial([1,2,3])\nPolynomial(1 + 2*x + 3*x^2)\n\njulia> x = variable()\nPolynomial(x)\n\njulia> x^degree(p) * p(x⁻¹) # reverses  coefficients\nLaurentPolynomial(3.0 + 2.0*x + 1.0*x²)\n\n\n\n\n\n","category":"type"},{"location":"polynomials/polynomial/#Factored-Polynomial","page":"Polynomial","title":"Factored Polynomial","text":"","category":"section"},{"location":"polynomials/polynomial/#Polynomials.FactoredPolynomial","page":"Polynomial","title":"Polynomials.FactoredPolynomial","text":"FactoredPolynomial{T,X}\n\nA polynomial type that stores its data in a dictionary whose keys are the roots and whose values are the respective multiplicities along with a leading coefficient.\n\nThe structure is utilized for scalar multiplication, polynomial multiplication and powers, the finding of roots, and the identification of a greatest common divisor. For other operations, say addition, the operation is done after converting to the Polynomial type then converting back. (This requires the identification of the roots, so is subject to numeric issues.)\n\nExamples\n\njulia> using Polynomials\n\njulia> p = FactoredPolynomial(Dict([0=>1, 1=>2, 3=>4]))\nFactoredPolynomial(x * (x - 3)⁴ * (x - 1)²)\n\njulia> q = fromroots(FactoredPolynomial, [0,1,2,3])\nFactoredPolynomial((x - 3) * x * (x - 2) * (x - 1))\n\njulia> p*q\nFactoredPolynomial(x² * (x - 3)⁵ * (x - 1)³ * (x - 2))\n\njulia> p^1000\nFactoredPolynomial(x¹⁰⁰⁰ * (x - 3)⁴⁰⁰⁰ * (x - 1)²⁰⁰⁰)\n\njulia> gcd(p,q)\nFactoredPolynomial(x * (x - 3) * (x - 1))\n\njulia> p = Polynomial([24, -50, 35, -10, 1])\nPolynomial(24 - 50*x + 35*x^2 - 10*x^3 + x^4)\n\njulia> q = convert(FactoredPolynomial, p) # noisy form of `factor`:\nFactoredPolynomial((x - 4.0000000000000036) * (x - 1.0000000000000002) * (x - 2.9999999999999942) * (x - 2.0000000000000018))\n\njulia> map(x->round(x, digits=12), q) # map works over factors and leading coefficient -- not coefficients in the standard basis\nFactoredPolynomial((x - 4.0) * (x - 2.0) * (x - 3.0) * (x - 1.0))\n\n\n\n\n\n","category":"type"},{"location":"polynomials/polynomial/#Rational-Function","page":"Polynomial","title":"Rational Function","text":"","category":"section"},{"location":"polynomials/polynomial/#Polynomials.RationalFunction","page":"Polynomial","title":"Polynomials.RationalFunction","text":"RationalFunction(p::AbstractPolynomial, q::AbstractPolynomial)\np // q\n\nCreate a rational expression (p//q) from the two polynomials.\n\nCommon factors are not cancelled by the constructor, as they are for the base Rational type. The lowest_terms function attempts that operation.\n\nFor purposes of iteration, a rational function is treated like a two-element container.\n\nExamples\n\njulia> using Polynomials\n\njulia> p,q = fromroots(Polynomial, [1,2,3]), fromroots(Polynomial, [2,3,4])\n(Polynomial(-6 + 11*x - 6*x^2 + x^3), Polynomial(-24 + 26*x - 9*x^2 + x^3))\n\njulia> pq = p // q\n(-6 + 11*x - 6*x^2 + x^3) // (-24 + 26*x - 9*x^2 + x^3)\n\njulia> lowest_terms(pq)\n(-0.333333 + 0.333333*x) // (-1.33333 + 0.333333*x)\n\njulia> pq(2.5)\n-1.0\n\njulia> pq(2) # uses first non-`0/0` ratio of `p⁽ᵏ⁾/q⁽ᵏ⁾`\n-0.5\n\njulia> pq^2\n(36 - 132*x + 193*x^2 - 144*x^3 + 58*x^4 - 12*x^5 + x^6) // (576 - 1248*x + 1108*x^2 - 516*x^3 + 133*x^4 - 18*x^5 + x^6)\n\njulia> derivative(pq)\n(-108 + 180*x - 111*x^2 + 30*x^3 - 3*x^4) // (576 - 1248*x + 1108*x^2 - 516*x^3 + 133*x^4 - 18*x^5 + x^6)\n\nnote: Note\nThe RationalFunctions.jl package was a helpful source of ideas.\n\nnote: Note\nThe ImmutablePolynomial type can not be used for rational functions, as the type requires the numerator and denominator to have the exact same type.\n\n\n\n\n\n","category":"type"},{"location":"polynomials/polynomial/#Polynomials.lowest_terms","page":"Polynomial","title":"Polynomials.lowest_terms","text":"lowest_terms(pq::AbstractRationalFunction, method=:numerical)\n\nFind GCD of (p,q), u, and return (p÷u)//(q÷u). Commonly referred to as lowest terms.\n\nmethod: passed to gcd(p,q)\nkwargs: passed to gcd(p,q)\n\nBy default, AbstractRationalFunction types do not cancel common factors. This method will numerically cancel common factors, returning the normal form, canonicalized here by q[end]=1. The result and original may be considered equivalent as rational expressions, but different when seen as functions of the indeterminate.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Reference/API","page":"Reference/API","title":"Reference/API","text":"","category":"section"},{"location":"reference/","page":"Reference/API","title":"Reference/API","text":"All polynomials have the following functionality. In some cases, there is not a direct function call and therefore the polynomials have to be converted to the standard Polynomial type before continuing.","category":"page"},{"location":"reference/","page":"Reference/API","title":"Reference/API","text":"Pages = [\"reference.md\"]","category":"page"},{"location":"reference/#Arithmetic","page":"Reference/API","title":"Arithmetic","text":"","category":"section"},{"location":"reference/","page":"Reference/API","title":"Reference/API","text":"All AbstractPolynomials have basic arithmetic operations defined on them (+, -, *, /, ÷, %, ==).","category":"page"},{"location":"reference/","page":"Reference/API","title":"Reference/API","text":"julia> p = Polynomial([1, 2])\nPolynomial(1 + 2*x)\n\njulia> q = Polynomial([1, 0, -1])\nPolynomial(1 - x^2)\n\njulia> 2p\nPolynomial(2 + 4*x)\n\njulia> 2 + p\nPolynomial(3 + 2*x)\n\njulia> p - q\nPolynomial(2*x + x^2)\n\njulia> p * q\nPolynomial(1 + 2*x - x^2 - 2*x^3)\n\njulia> q / 2\nPolynomial(0.5 - 0.5*x^2)","category":"page"},{"location":"reference/#Inspection","page":"Reference/API","title":"Inspection","text":"","category":"section"},{"location":"reference/#Polynomials.degree","page":"Reference/API","title":"Polynomials.degree","text":"degree(::AbstractPolynomial)\n\nReturn the degree of the polynomial, i.e. the highest exponent in the polynomial that has a nonzero coefficient.\n\nFor standard basis polynomials the degree of the zero polynomial is defined to be -1. For Laurent type polynomials, this is 0, or lastindex(p). The firstindex method gives the smallest power of the indeterminate for the polynomial. The default method assumes the basis polynomials, βₖ, have degree k.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Base.length","page":"Reference/API","title":"Base.length","text":"length(::AbstractPolynomial)\n\nThe length of the polynomial.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Base.size","page":"Reference/API","title":"Base.size","text":"size(::AbstractPolynomial, [i])\n\nReturns the size of the polynomials coefficients, along axis i if provided.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Polynomials.domain","page":"Reference/API","title":"Polynomials.domain","text":"Polynomials.domain(::Type{<:AbstractPolynomial})\n\nReturns the domain of the polynomial.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Polynomials.mapdomain","page":"Reference/API","title":"Polynomials.mapdomain","text":"mapdomain(::Type{<:AbstractPolynomial}, x::AbstractArray)\nmapdomain(::AbstractPolynomial, x::AbstractArray)\n\nGiven values of x that are assumed to be unbounded (-∞, ∞), return values rescaled to the domain of the given polynomial.\n\nExamples\n\njulia> using Polynomials\n\njulia> x = -10:10\n-10:10\n\njulia> extrema(mapdomain(ChebyshevT, x))\n(-1.0, 1.0)\n\n\n\n\n\n\n","category":"function"},{"location":"reference/#Base.chop","page":"Reference/API","title":"Base.chop","text":"chop(::AbstractPolynomial{T};\n    rtol::Real = Base.rtoldefault(real(T)), atol::Real = 0))\n\nRemoves any leading coefficients that are approximately 0 (using rtol and atol with norm(p)). Returns a polynomial whose degree will guaranteed to be equal to or less than the given polynomial's.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Polynomials.chop!","page":"Reference/API","title":"Polynomials.chop!","text":"chop!(::AbstractPolynomial{T};\n    rtol::Real = Base.rtoldefault(real(T)), atol::Real = 0))\n\nIn-place version of chop\n\n\n\n\n\n","category":"function"},{"location":"reference/#Base.truncate","page":"Reference/API","title":"Base.truncate","text":"truncate(::AbstractPolynomial{T};\n    rtol::Real = Base.rtoldefault(real(T)), atol::Real = 0)\n\nRounds off coefficients close to zero, as determined by rtol and atol, and then chops any leading zeros. Returns a new polynomial.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Polynomials.truncate!","page":"Reference/API","title":"Polynomials.truncate!","text":"truncate!(::AbstractPolynomial{T};\n    rtol::Real = Base.rtoldefault(real(T)), atol::Real = 0)\n\nIn-place version of truncate\n\n\n\n\n\n","category":"function"},{"location":"reference/#Base.iszero","page":"Reference/API","title":"Base.iszero","text":"iszero(p::AbstractPolynomial)\n\nIs this a 0 polynomial.\n\nFor most types, the 0 polynomial is one with no coefficients (coefficient vector T[]), though some types have the possibility of trailing zeros. The degree of a zero polynomial is conventionally -1, though this is not the convention for Laurent polynomials.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Polynomials.isconstant","page":"Reference/API","title":"Polynomials.isconstant","text":"isconstant(::AbstractPolynomial)\n\nIs the polynomial  p a constant.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Polynomials.constantterm","page":"Reference/API","title":"Polynomials.constantterm","text":"constantterm(p::AbstractPolynomial)\n\nreturn p(0), the constant term in the standard basis\n\n\n\n\n\n","category":"function"},{"location":"reference/#Base.isreal","page":"Reference/API","title":"Base.isreal","text":"isreal(p::AbstractPolynomial)\n\nDetermine whether a polynomial is a real polynomial, i.e., having only real numbers as coefficients.\n\nSee also: real\n\n\n\n\n\n","category":"function"},{"location":"reference/#Base.real","page":"Reference/API","title":"Base.real","text":"real(p::AbstractPolynomial)\n\nConstruct a real polynomial from the real parts of the coefficients of p.\n\nSee also: isreal\n\nnote: Note\nThis could cause losing terms in p. This method is usually called on polynomials like p = Polynomial([1, 2 + 0im, 3.0, 4.0 + 0.0im]) where you want to chop the imaginary parts of the coefficients of p.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Polynomials.isintegral","page":"Reference/API","title":"Polynomials.isintegral","text":"isintegral(p::AbstractPolynomial)\n\nDetermine whether a polynomial is an integer polynomial, i.e., having only integers as coefficients.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Polynomials.ismonic","page":"Reference/API","title":"Polynomials.ismonic","text":"ismonic(p::AbstractPolynomial)\n\nDetermine whether a polynomial is a monic polynomial, i.e., its leading coefficient is one.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Polynomials.hasnan","page":"Reference/API","title":"Polynomials.hasnan","text":"hasnan(p::AbstractPolynomial) are any coefficients NaN\n\n\n\n\n\n","category":"function"},{"location":"reference/#Iteration","page":"Reference/API","title":"Iteration","text":"","category":"section"},{"location":"reference/","page":"Reference/API","title":"Reference/API","text":"For the Polynomial  type, a natural mapping between the polynomial a_0 + a_1 x + a_2 x^2 + cdots + a_n x^n with the coefficients (a_0 a_1 dots a_n)) leads to the view point of a polynomial being a 0-based vector. Similarly, when the basis terms are not the standard basis. The coeffs method returns these coefficients in an iterable (a vector or tuple). For Laurent type polynomials, the coefficients between firstindex(p) and lastindex(p) are returned.","category":"page"},{"location":"reference/","page":"Reference/API","title":"Reference/API","text":"More generally, pairs(p) returns values i => aᵢ where the polynomial has terms a_i T_i for the basis T_i. (For sparse polynomials these need not be in order and only terms where a_i ne 0 are given.) The keys and values methods iterate over i and aᵢ.","category":"page"},{"location":"reference/","page":"Reference/API","title":"Reference/API","text":"The firstindex method refers to the lowest stored basis index, which due to offsets need not be 0. It will be no smaller than Polynomials.minimumexponent, which is the smalled allowed index for the polynomial type. The lastindex method refers to the last basis index. If the type allows trailing zeros (like ImmutablePolynomial) this will differ from the value returned by degree.","category":"page"},{"location":"reference/","page":"Reference/API","title":"Reference/API","text":"The getindex(p,i) method returns p_i or zero when out of bounds (if the element type of the polynomial has zero(T) defined). For mutable polynomials, the setindex!(p, val, i) method sets p[i] to val. This may extend  the underlying storage container for some polynomial types. For ImmutablePolynomial the @set! macro from Setfield can be used with the typical setindex! notation.","category":"page"},{"location":"reference/","page":"Reference/API","title":"Reference/API","text":"The map(fn, p) method maps fn over the coefficients and returns a polynomial with the same polynomial type as p.","category":"page"},{"location":"reference/#Polynomials.coeffs","page":"Reference/API","title":"Polynomials.coeffs","text":"coeffs(::AbstractPolynomial)\ncoeffs(::AbstractDenseUnivariatePolynomial)\ncoeffs(::AbstractLaurentUnivariatePolynomial)\n\nFor a dense, univariate polynomial return the coefficients (a_0 a_1 dots a_n) as an interable. This may be a vector or tuple, and may alias the polynomials coefficients.\n\nFor a Laurent type polynomial (e.g. LaurentPolynomial, SparsePolynomial) return the coefficients (a_i a_i+1 dots a_j) where i is found from firstindex(p) and j from lastindex(p).\n\nFor LaurentPolynomial and SparsePolynomial, the pairs iterator is more generically useful, as it iterates over (i p_i) possibly skipping the terms where p_i = 0.\n\nDefaults to p.coeffs.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Base.pairs","page":"Reference/API","title":"Base.pairs","text":"pairs(p::AbstractPolynomial)\n\nIterator over (i p_i) for each basis element, beta_i, represented by the coefficients.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Base.values","page":"Reference/API","title":"Base.values","text":"values(p::AbstractPolynomial)\n\nIterator over p_is for each basis element, beta_i, represented by the coefficients.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Base.keys","page":"Reference/API","title":"Base.keys","text":"keys(p::AbstractPolynomial)\n\nIterator over is for each basis element, beta_i, represented by the coefficients.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Base.firstindex","page":"Reference/API","title":"Base.firstindex","text":"firstindex(p::AbstractPolynomial)\n\nThe index of the smallest basis element, beta_i,  represented by the coefficients. This is 0 for a zero polynomial.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Base.lastindex","page":"Reference/API","title":"Base.lastindex","text":"lastindex(p::AbstractPolynomial)\n\nThe index of the largest basis element, beta_i,  represented by the coefficients. May be -1 or 0 for the zero polynomial, depending on the storage type.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Base.eachindex","page":"Reference/API","title":"Base.eachindex","text":"eachindex(p::AbstractPolynomial)\n\nIterator over all indices of the represented basis elements\n\n\n\n\n\n","category":"function"},{"location":"reference/#Base.map","page":"Reference/API","title":"Base.map","text":"map(fn, p::AbstractPolynomial, args...)\n\nTransform coefficients of p by applying a function (or other callables) fn to each of them.\n\nYou can implement real, etc., to a Polynomial by using map. The type of p may narrow using this function.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Mathematical-Functions","page":"Reference/API","title":"Mathematical Functions","text":"","category":"section"},{"location":"reference/#Base.zero","page":"Reference/API","title":"Base.zero","text":"zero(::Type{<:AbstractPolynomial})\nzero(::AbstractPolynomial)\n\nReturns a representation of 0 as the given polynomial.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Base.one","page":"Reference/API","title":"Base.one","text":"one(::Type{<:AbstractPolynomial})\none(::AbstractPolynomial)\n\nReturns a representation of 1 as the given polynomial.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Polynomials.variable","page":"Reference/API","title":"Polynomials.variable","text":"variable(var=:x)\nvariable(::Type{<:AbstractPolynomial}, var=:x)\nvariable(p::AbstractPolynomial, var=indeterminate(p))\n\nReturn the monomial x in the indicated polynomial basis.  If no type is give, will default to Polynomial. Equivalent to P(var).\n\nExamples\n\njulia> using Polynomials\n\njulia> x = variable()\nPolynomial(x)\n\njulia> p = 100 + 24x - 3x^2\nPolynomial(100 + 24*x - 3*x^2)\n\njulia> roots((x - 3) * (x + 2))\n2-element Vector{Float64}:\n -2.0\n  3.0\n\n\n\n\n\n","category":"function"},{"location":"reference/#Polynomials.basis","page":"Reference/API","title":"Polynomials.basis","text":"basis(p::P, i::Int)\nbasis(::Type{<:AbstractPolynomial}, i::Int, var=:x)\n\nReturn ith basis element for a given polynomial type, optionally with a specified variable.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Polynomials.fromroots","page":"Reference/API","title":"Polynomials.fromroots","text":"fromroots(::AbstractVector{<:Number}; var=:x)\nfromroots(::Type{<:AbstractPolynomial}, ::AbstractVector{<:Number}; var=:x)\n\nConstruct a polynomial of the given type given the roots. If no type is given, defaults to Polynomial.\n\nExamples\n\njulia> using Polynomials\n\njulia> r = [3, 2]; # (x - 3)(x - 2)\n\njulia> fromroots(r)\nPolynomial(6 - 5*x + x^2)\n\n\n\n\n\nfromroots(::AbstractMatrix{<:Number}; var=:x)\nfromroots(::Type{<:AbstractPolynomial}, ::AbstractMatrix{<:Number}; var=:x)\n\nConstruct a polynomial of the given type using the eigenvalues of the given matrix as the roots. If no type is given, defaults to Polynomial.\n\nExamples\n\njulia> using Polynomials\n\njulia> A = [1 2; 3 4]; # (x - 5.37228)(x + 0.37228)\n\njulia> fromroots(A)\nPolynomial(-1.9999999999999998 - 5.0*x + 1.0*x^2)\n\n\n\n\n\n","category":"function"},{"location":"reference/#Base.gcd","page":"Reference/API","title":"Base.gcd","text":"gcd(a::AbstractPolynomial, b::AbstractPolynomial; atol::Real=0, rtol::Real=Base.rtoldefault)\n\nFind the greatest common denominator of two polynomials recursively using Euclid's algorithm.\n\nExamples\n\njulia> using Polynomials\n\njulia> gcd(fromroots([1, 1, 2]), fromroots([1, 2, 3]))\nPolynomial(4.0 - 6.0*x + 2.0*x^2)\n\n\n\n\n\ngcd(p1::StandardBasisPolynomial, p2::StandardBasisPolynomial; method=:euclidean, kwargs...)\n\nFind the greatest common divisor.\n\nBy default, uses the Euclidean division algorithm (method=:euclidean), which is susceptible to floating point issues.\n\nPassing method=:noda_sasaki uses scaling to circumvent some of these.\n\nPassing method=:numerical will call the internal method NGCD.ngcd for the numerical gcd. See the docstring of NGCD.ngcd for details.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Polynomials.derivative","page":"Reference/API","title":"Polynomials.derivative","text":"derivative(::AbstractPolynomial, order::Int = 1)\n\nReturns a polynomial that is the orderth derivative of the given polynomial. order must be non-negative.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Polynomials.integrate","page":"Reference/API","title":"Polynomials.integrate","text":"integrate(p::AbstractPolynomial)\n\nReturn an antiderivative for p\n\n\n\n\n\nintegrate(::AbstractPolynomial, C)\n\nReturns the indefinite integral of the polynomial with constant C when expressed in the standard basis.\n\n\n\n\n\nintegrate(::AbstractPolynomial, a, b)\n\nCompute the definite integral of the given polynomial from a to b. Will throw an error if either a or b are out of the polynomial's domain.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Polynomials.roots","page":"Reference/API","title":"Polynomials.roots","text":"roots(::AbstractPolynomial; kwargs...)\n\nReturns the roots, or zeros, of the given polynomial.\n\nFor non-factored, standard basis polynomials the roots are calculated via the eigenvalues of the companion matrix. The kwargs are passed to the LinearAlgebra.eigvals call.\n\nnote: Note\nThe default roots implementation is for polynomials in the standard basis. The companion matrix approach is reasonably fast and accurate for modest-size polynomials. However, other packages in the Julia ecosystem may be of interest and are mentioned in the documentation.\n\n\n\n\n\nroots(pq::AbstractRationalFunction; kwargs...)\n\nReturn the zeros of the rational function (after cancelling commong factors, the zeros are the roots of the numerator.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Polynomials.companion","page":"Reference/API","title":"Polynomials.companion","text":"companion(::AbstractPolynomial)\n\nReturn the companion matrix for the given polynomial.\n\nReferences\n\nCompanion Matrix\n\n\n\n\n\n","category":"function"},{"location":"reference/#Polynomials.fit","page":"Reference/API","title":"Polynomials.fit","text":"fit(x, y, deg=length(x) - 1; [weights], var=:x)\nfit(::Type{<:AbstractPolynomial}, x, y, deg=length(x)-1; [weights], var=:x)\n\nFit the given data as a polynomial type with the given degree. Uses linear least squares to minimize the norm  ||y - V⋅β||^2, where V is the Vandermonde matrix and β are the coefficients of the polynomial fit.\n\nThis will automatically scale your data to the domain of the polynomial type using mapdomain. The default polynomial type is Polynomial.\n\nWeights\n\nWeights may be assigned to the points by specifying a vector or matrix of weights.\n\nWhen specified as a vector, [w₁,…,wₙ], the weights should be non-negative as the minimization problem is argmin_β Σᵢ wᵢ |yᵢ - Σⱼ Vᵢⱼ βⱼ|² = argmin_β || √(W)⋅(y - V(x)β)||², where, W the diagonal matrix formed from [w₁,…,wₙ], is used for the solution, V being the Vandermonde matrix of x corresponding to the specified degree. This parameterization of the weights is different from that of numpy.polyfit, where the weights would be specified through [ω₁,ω₂,…,ωₙ] = [√w₁, √w₂,…,√wₙ] with the answer solving argminᵦ | (ωᵢ⋅yᵢ- ΣⱼVᵢⱼ(ω⋅x) βⱼ) |^2.\n\nWhen specified as a matrix, W, the solution is through the normal equations (VᵀWV)β = (Vᵀy), again V being the Vandermonde matrix of x corresponding to the specified degree.\n\n(In statistics, the vector case corresponds to weighted least squares, where weights are typically given by wᵢ = 1/σᵢ², the σᵢ² being the variance of the measurement; the matrix specification follows that of the generalized least squares estimator with W = Σ⁻¹, the inverse of the variance-covariance matrix.)\n\nlarge degree\n\nFor fitting with a large degree, the Vandermonde matrix is exponentially ill-conditioned. The ArnoldiFit type introduces an Arnoldi orthogonalization that fixes this problem.\n\n\n\n\n\nfit(P::Type{<:StandardBasisPolynomial}, x, y, J, [cs::Dict{Int, T}]; weights, var)\n\nUsing constrained least squares, fit a polynomial of the type p = ∑_{i ∈ J} aᵢ xⁱ + ∑ cⱼxʲ where cⱼ are fixed non-zero constants\n\nJ: a collection of degrees to find coefficients for\ncs: If given, a Dict of key/values, i => cᵢ, which indicate the degree and value of the fixed non-zero constants.\n\nThe degrees in cs and those in J should not intersect.\n\nExample\n\nx = range(0, pi/2, 10)\ny = sin.(x)\nP = Polynomial\np0 = fit(P, x, y, 5)\np1 = fit(P, x, y, 1:2:5)\np2 = fit(P, x, y, 3:2:5, Dict(1 => 1))\n[norm(p.(x) - y) for p ∈ (p0, p1, p2)] # 1.7e-5, 0.00016, 0.000248\n\n\n\n\n\nfit(::Type{RationalFunction}, xs::AbstractVector{S}, ys::AbstractVector{T}, m, n; var=:x)\n\nFit a rational function of the form pq = (a₀ + a₁x¹ + … + aₘxᵐ) / (1 + b₁x¹ + … + bₙxⁿ) to the data (x,y).\n\nnote: Note\nThis uses a simple implementation of the Gauss-Newton method to solve the non-linear least squares problem: minᵦ Σ(yᵢ - pq(xᵢ,β)², where β=(a₀,a₁,…,aₘ,b₁,…,bₙ).A more rapidly convergent method is used in the LsqFit.jl package, and if performance is important, re-expressing the problem for use with that package is suggested.Further, if an accurate rational function fit of adaptive degrees is of interest, the BaryRational.jl package provides an implementation of the AAA algorithm (\"which offers speed, flexibility, and robustness we have not seen in other algorithms\" Nakatsukasa, Sète, Trefethen) and one using Floater-Hormann weights Floater, Hormann (\"that have no real poles and arbitrarily high approximation orders on any real interval, regardless of the distribution of the points\")The RationalApproximations package also has implementations of the AAA algorithm.A python library, polyrat, has implementations of other algorithms.\n\nExample\n\njulia> x = variable(Polynomial{Float64})\nPolynomial(1.0*x)\n\njulia> pq = (1+x)//(1-x)\n(1.0 + 1.0*x) // (1.0 - 1.0*x)\n\njulia> xs = 2.0:.1:3;\n\njulia> ys = pq.(xs);\n\njulia> v = fit(RationalFunction, xs, ys, 2, 2)\n(1.0 + 1.0*x - 6.82121e-13*x^2) // (1.0 - 1.0*x + 2.84217e-13*x^2)\n\njulia> maximum(abs, v(x)-pq(x) for x ∈ 2.1:0.1:3.0)\n1.06314956838105e-12\n\njulia> using BaryRational\n\njulia> u = aaa(xs,ys)\n(::BaryRational.AAAapprox{Vector{Float64}}) (generic function with 1 method)\n\njulia> maximum(abs, u(x)-pq(x) for x ∈ 2.1:0.1:3.0)\n4.440892098500626e-16\n\njulia> u(variable(pq)) # to see which polynomial is used\n(2.68328 + 0.447214*x - 1.78885*x^2 + 0.447214*x^3) // (2.68328 - 4.91935*x + 2.68328*x^2 - 0.447214*x^3)\n\n\n\n\n\nfit(::Type{RationalFunction}, r::Polynomial, m, n; var=:x)\n\nFit a Pade approximant (cf docstring for Polynomials.pade_fit) to r.\n\nExamples:\n\njulia> using Polynomials, PolynomialRatios\n\njulia> x = variable()\nPolynomial(x)\n\njulia> ex = 1 + x + x^2/2 + x^3/6 + x^4/24 + x^5/120 # Taylor polynomial for e^x\nPolynomial(1.0 + 1.0*x + 0.5*x^2 + 0.16666666666666666*x^3 + 0.041666666666666664*x^4 + 0.008333333333333333*x^5)\n\njulia> maximum(abs, exp(x) - fit(RationalFunction, ex, 1,1)(x) for x ∈ 0:.05:0.5)\n0.017945395966538547\n\njulia> maximum(abs, exp(x) - fit(RationalFunction, ex, 1,2)(x) for x ∈ 0:.05:0.5)\n0.0016624471707165078\n\njulia> maximum(abs, exp(x) - fit(RationalFunction, ex, 2,1)(x) for x ∈ 0:.05:0.5)\n0.001278729299871717\n\njulia> maximum(abs, exp(x) - fit(RationalFunction, ex, 2,2)(x) for x ∈ 0:.05:0.5)\n7.262205147950951e-5\n\n\n\n\n\n","category":"function"},{"location":"reference/#Polynomials.vander","page":"Reference/API","title":"Polynomials.vander","text":"vander(::Type{AbstractPolynomial}, x::AbstractVector, deg::Integer)\n\nCalculate the pseudo-Vandermonde matrix of the given polynomial type with the given degree.\n\nReferences\n\nVandermonde Matrix\n\n\n\n\n\n","category":"function"},{"location":"reference/#Plotting","page":"Reference/API","title":"Plotting","text":"","category":"section"},{"location":"reference/","page":"Reference/API","title":"Reference/API","text":"Polynomials can be plotted directly using Plots.jl or Makie.jl.","category":"page"},{"location":"reference/","page":"Reference/API","title":"Reference/API","text":"plot(::AbstractPolynomial; kwds...)","category":"page"},{"location":"reference/","page":"Reference/API","title":"Reference/API","text":"will automatically determine a range based on the critical points (roots, extrema and points of inflection).","category":"page"},{"location":"reference/","page":"Reference/API","title":"Reference/API","text":"plot(::AbstractPolynomial, a, b; kwds...)","category":"page"},{"location":"reference/","page":"Reference/API","title":"Reference/API","text":"will plot the polynomial within the range [a, b].","category":"page"},{"location":"reference/#Example:-The-Polynomials.jl-logo","page":"Reference/API","title":"Example: The Polynomials.jl logo","text":"","category":"section"},{"location":"reference/","page":"Reference/API","title":"Reference/API","text":"using Plots, Polynomials\n# T1, T2, T3, and T4:\nchebs = [\n  ChebyshevT([0, 1]),\n  ChebyshevT([0, 0, 1]),\n  ChebyshevT([0, 0, 0, 1]),\n  ChebyshevT([0, 0, 0, 0, 1]),\n]\ncolors = [\"#4063D8\", \"#389826\", \"#CB3C33\", \"#9558B2\"]\n\np = plot(legend=false, label=\"\")\nfor (cheb, col) in zip(chebs, colors)\n  plot!(cheb, c=col, lw=5)\nend\nsavefig(\"chebs.svg\"); nothing # hide","category":"page"},{"location":"reference/","page":"Reference/API","title":"Reference/API","text":"(Image: )","category":"page"},{"location":"#Polynomials.jl","page":"Home","title":"Polynomials.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Polynomials.jl is a Julia package that provides basic arithmetic, integration, differentiation, evaluation, root finding, and data fitting for univariate polynomials.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The Polynomials package is hosted on GitHub and installed as other Julia packages. As of version v3.0.0 Julia version 1.6 or higher is required.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The package can be loaded into the current session through","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Polynomials","category":"page"},{"location":"#Construction-and-Evaluation","page":"Home","title":"Construction and Evaluation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Construct a polynomial from its coefficients, lowest order first.","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> Polynomial([1,0,3,4])\nPolynomial(1 + 3*x^2 + 4*x^3)","category":"page"},{"location":"","page":"Home","title":"Home","text":"An optional variable parameter can be added.","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> Polynomial([1,2,3], :s)\nPolynomial(1 + 2*s + 3*s^2)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Construct a polynomial from its roots.","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> fromroots([1,2,3]) # (x-1)*(x-2)*(x-3)\nPolynomial(-6 + 11*x - 6*x^2 + x^3)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Evaluate the polynomial p at 1 using call notation:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> p = Polynomial([1, 0, -1])\nPolynomial(1 - x^2)\n\njulia> p(1)\n0","category":"page"},{"location":"","page":"Home","title":"Home","text":"The Polynomial constructor stores all coefficients using the standard basis with a vector. Other types (e.g. ImmutablePolynomial, SparsePolynomial, or FactoredPolynomial) use different back-end containers which may have advantage for some uses.","category":"page"},{"location":"#Arithmetic","page":"Home","title":"Arithmetic","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The usual arithmetic operators are overloaded to work on polynomials, and combinations of polynomials and scalars.","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> p = Polynomial([1,2])\nPolynomial(1 + 2*x)\n\njulia> q = Polynomial([1, 0, -1])\nPolynomial(1 - x^2)\n\njulia> 2p\nPolynomial(2 + 4*x)\n\njulia> 2 + p\nPolynomial(3 + 2*x)\n\njulia> p - q\nPolynomial(2*x + x^2)\n\njulia> p * q\nPolynomial(1 + 2*x - x^2 - 2*x^3)\n\njulia> q / 2\nPolynomial(0.5 - 0.5*x^2)\n\njulia> q ÷ p  # `div`, also `rem` and `divrem`\nPolynomial(0.25 - 0.5*x)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Note that operations involving polynomials with different variables will error.","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> p = Polynomial([1, 2, 3], :x)\nPolynomial(1 + 2*x + 3*x^2)\n\njulia> q = Polynomial([1, 2, 3], :s)\nPolynomial(1 + 2*s + 3*s^2)\n\njulia> p + q\nERROR: ArgumentError: Polynomials have different indeterminates\n[...]","category":"page"},{"location":"","page":"Home","title":"Home","text":"Except for operations involving constant polynomials.","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> p = Polynomial([1, 2, 3], :x)\nPolynomial(1 + 2*x + 3*x^2)\n\njulia> q = Polynomial(1, :y)\nPolynomial(1)\n\njulia> p + q\nPolynomial(2 + 2*x + 3*x^2)","category":"page"},{"location":"#Mixing-polynomial-types","page":"Home","title":"Mixing polynomial types","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Arithmetic of different polynomial types is supported through promotion to a common type, which is typically the Polynomial type, but may be the LaurentPolynomial type when negative powers of the indeterminate are possible:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> p, q = ImmutablePolynomial([1,2,3]), Polynomial([3,2,1])\n(ImmutablePolynomial(1 + 2*x + 3*x^2), Polynomial(3 + 2*x + x^2))\n\njulia> p + q\nPolynomial(4 + 4*x + 4*x^2)\n\njulia> p, q = ImmutablePolynomial([1,2,3]), SparsePolynomial(Dict(0=>1, 2=>3, 10=>1))\n(ImmutablePolynomial(1 + 2*x + 3*x^2), SparsePolynomial(1 + 3*x^2 + x^10))\n\njulia> p + q\nLaurentPolynomial(2 + 2*x + 6*x² + x¹⁰)","category":"page"},{"location":"#Integrals-and-Derivatives","page":"Home","title":"Integrals and Derivatives","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Integrate the polynomial p term by term, optionally adding constant term C. For non-zero polynomials, the degree of the resulting polynomial is one higher than the degree of p.","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> integrate(Polynomial([1, 0, -1]))\nPolynomial(1.0*x - 0.3333333333333333*x^3)\n\njulia> integrate(Polynomial([1, 0, -1]), 2)\nPolynomial(2.0 + 1.0*x - 0.3333333333333333*x^3)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Differentiate the polynomial p term by term. For non-zero polynomials, the degree of the resulting polynomial is one lower than the degree of p.","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> derivative(Polynomial([1, 3, -1]))\nPolynomial(3 - 2*x)","category":"page"},{"location":"#Root-finding","page":"Home","title":"Root-finding","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Return the d roots (or zeros) of the degree d polynomial p.","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> roots(Polynomial([1, 0, -1]))\n2-element Vector{Float64}:\n -1.0\n  1.0\n\njulia> roots(Polynomial([1, 0, 1]))\n2-element Vector{ComplexF64}:\n 0.0 - 1.0im\n 0.0 + 1.0im\n\njulia> roots(Polynomial([0, 0, 1]))\n2-element Vector{Float64}:\n 0.0\n 0.0","category":"page"},{"location":"","page":"Home","title":"Home","text":"By design, this is not type-stable; the return type may be real or complex.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The default roots function uses the eigenvalues of the companion matrix for a polynomial. This is an 𝑶(n^3) operation.","category":"page"},{"location":"","page":"Home","title":"Home","text":"For polynomials with BigFloat coefficients, the GenericLinearAlgebra package can be seamlessly used:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> p = fromroots(Polynomial{BigFloat}, [1,2,3])\nPolynomial(-6.0 + 11.0*x - 6.0*x^2 + 1.0*x^3)\n\njulia> roots(p)\nERROR: MethodError: no method matching eigvals!(::Matrix{BigFloat})\n[...]\n\njulia> using GenericLinearAlgebra\n\njulia> roots(p)\n3-element Vector{Complex{BigFloat}}:\n 0.9999999999999999999999999999999999999999999999999999999999999999999999999999655 + 0.0im\n  1.999999999999999999999999999999999999999999999999999999999999999999999999999931 - 0.0im\n  2.999999999999999999999999999999999999999999999999999999999999999999999999999793 + 0.0im","category":"page"},{"location":"#Comments-on-root-finding","page":"Home","title":"Comments on root finding","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The PolynomialRoots.jl package provides an alternative approach for finding complex roots to univariate polynomials that is more performant than roots. It is based on an algorithm of Skowron and Gould.\njulia> import PolynomialRoots # import as `roots` conflicts\n\njulia> p = fromroots(Polynomial, [1,2,3])\nPolynomial(-6 + 11*x - 6*x^2 + x^3)\n\njulia> PolynomialRoots.roots(coeffs(p))\n3-element Vector{ComplexF64}:\n  3.000000000000001 - 0.0im\n 1.9999999999999993 + 0.0im\n 1.0000000000000002 + 0.0im\nThe roots are always returned as complex numbers.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The FastPolynomialRoots package provides an interface to FORTRAN code implementing an algorithm of Aurentz, Mach, Robol, Vandrebril, and Watkins. that can handle very large polynomials (it is 𝑶(n^2) and backward stable). The AMRVW.jl package implements the algorithm in Julia, allowing the use of other number types.\njulia> using AMRVW\n\njulia> AMRVW.roots(float.(coeffs(p)))\n3-element Vector{ComplexF64}:\n 0.9999999999999997 + 0.0im\n 2.0000000000000036 + 0.0im\n 2.9999999999999964 + 0.0im\nThe roots are returned as complex numbers.\nBoth PolynomialRoots and AMRVW are generic and work with BigFloat coefficients, for example.\nThe AMRVW package works with much larger polynomials than either roots or PolynomialRoots.roots. For example, the roots of this 1000 degree random polynomial are quickly and accurately solved for:\njulia> filter(isreal, AMRVW.roots(rand(1001) .- 1/2))\n2-element Vector{ComplexF64}:\n  0.993739974989572 + 0.0im\n 1.0014677846996498 + 0.0im\nThe Hecke package has a roots function. The Hecke package utilizes the Arb library for performant, high-precision numbers:\njulia> import Hecke # import as `roots` conflicts\n\njulia> Qx, x = Hecke.PolynomialRing(Hecke.QQ)\n(Univariate Polynomial Ring in x over Rational Field, x)\n\njulia> q = (x-1)*(x-2)*(x-3)\nx^3 - 6*x^2 + 11*x - 6\n\njulia> Hecke.roots(q)\n3-element Vector{Nemo.fmpq}:\n 2\n 1\n 3\nThis next polynomial has 3 real roots, 2 of which are in a cluster; Hecke quickly identifies them:\njulia> p = -1 + 254*x - 16129*x^2 + 1*x^17\nx^17 - 16129*x^2 + 254*x - 1\n\njulia> filter(isreal, Hecke._roots(p, 200)) # `_roots` not `roots`\n3-element Vector{Nemo.acb}:\n [0.007874015748031496052667730054749907629383970426203662570129818116411192289734968717460531379762086419 +/- 3.10e-103]\n [0.0078740157480314960733165219137540296086246589982151627453855179522742093785877068332663198273096875302 +/- 9.31e-104]\n [1.9066348541790688341521872066398429982632947292434604847312536201982593209326201234353468172497707769372732739429697289 +/- 7.14e-119]","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"To find just the real roots of a polynomial with real coefficients there are a few additional options to solving for all the roots and filtering by isreal.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The package IntervalRootFinding identifies real zeros of univariate functions and can be used to find isolating intervals for the real roots. For example,\njulia> using Polynomials, IntervalArithmetic\n\njulia> import IntervalRootFinding # its `roots` method conflicts with `roots`\n\njulia> p = fromroots(Polynomial, [1,2,3])\nPolynomial(-6 + 11*x - 6*x^2 + x^3)\n\njulia> IntervalRootFinding.roots(x -> p(x), 0..10)\n3-element Vector{IntervalRootFinding.Root{Interval{Float64}}}:\n Root([0.999999, 1.00001], :unique)\n Root([1.99999, 2.00001], :unique)\n Root([2.99999, 3.00001], :unique)\nThe output is a set of intervals. Those flagged with :unique are guaranteed to contain a unique root.\nThe RealPolynomialRoots package provides a function ANewDsc to find isolating intervals for  the roots of a square-free polynomial, specified through its coefficients:\njulia> using RealPolynomialRoots\n\njulia> st = ANewDsc(coeffs(p))\nThere were 3 isolating intervals found:\n[2.62…, 3.62…]₂₅₆\n[1.5…, 2.62…]₂₅₆\n[-0.50…, 1.5…]₂₅₆\nThese isolating intervals can be refined to find numeric estimates for the roots over BigFloat values.\njulia> refine_roots(st)\n3-element Vector{BigFloat}:\n 2.99999999999999999999...\n 2.00000000000000000000...\n 1.00000000000000000000...\nThis specialized algorithm can identify very nearby roots. For example, returning to this Mignotte-type polynomial:\njulia> p = SparsePolynomial(Dict(0=>-1, 1=>254, 2=>-16129, 17=>1))\nSparsePolynomial(-1 + 254*x - 16129*x^2 + x^17)\n\njulia> ANewDsc(coeffs(p))\nThere were 3 isolating intervals found:\n[1.5…, 3.5…]₅₃\n[0.0078740157480314960682066…, 0.0078740157480314960873178…]₁₃₉\n[0.0078740157480314960492543…, 0.0078740157480314960682066…]₁₃₉\nIntervalRootFinding has issues disambiguating the clustered roots of this example:\njulia> IntervalRootFinding.roots(x -> p(x), 0..3.5)\n7-element Vector{IntervalRootFinding.Root{Interval{Float64}}}:\n Root([1.90663, 1.90664], :unique)\n Root([0.00787464, 0.00787468], :unknown)\n Root([0.00787377, 0.00787387], :unknown)\n Root([0.00787405, 0.00787412], :unknown)\n Root([0.00787396, 0.00787406], :unknown)\n Root([0.00787425, 0.00787431], :unknown)\n Root([0.00787394, 0.00787397], :unknown)\nFor this example, filter(isreal, Hecke._roots(p)) also isolates the three real roots, but not quite as quickly.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Most of the root finding algorithms have issues when the roots have multiplicities. For example, both ANewDsc and Hecke.roots assume a square free polynomial. For non-square free polynomials:","category":"page"},{"location":"","page":"Home","title":"Home","text":"The Polynomials.Multroot.multroot function is available  for finding the roots of a polynomial and their multiplicities. This is based on work of Zeng.\nHere we see IntervalRootFinding.roots having trouble isolating the roots due to the multiplicities:\njulia> p = fromroots(Polynomial, [1,2,2,3,3])\nPolynomial(-36 + 96*x - 97*x^2 + 47*x^3 - 11*x^4 + x^5)\n\njulia> IntervalRootFinding.roots(x -> p(x), 0..10)\n335-element Vector{IntervalRootFinding.Root{Interval{Float64}}}:\n Root([1.99999, 2], :unknown)\n Root([1.99999, 2], :unknown)\n Root([3, 3.00001], :unknown)\n Root([2.99999, 3], :unknown)\n ⋮\n Root([2.99999, 3], :unknown)\n Root([2, 2.00001], :unknown)\nThe roots function identifies the roots, but the multiplicities would need identifying:\njulia> roots(p)\n5-element Vector{Float64}:\n 1.000000000000011\n 1.9999995886034314\n 2.0000004113969276\n 2.9999995304339646\n 3.0000004695656672\nWhereas, the roots along with the multiplicity structure are correctly identified with multroot:\njulia> Polynomials.Multroot.multroot(p)\n(values = [1.0000000000000004, 1.9999999999999984, 3.0000000000000018], multiplicities = [1, 2, 2], κ = 35.11176306900731, ϵ = 0.0)\nThe square_free function can help:\njulia> q = Polynomials.square_free(p)\nANewDsc(q)\nPolynomial(-0.20751433915978448 + 0.38044295512633425*x - 0.20751433915986722*x^2 + 0.03458572319332053*x^3)\n\njulia> IntervalRootFinding.roots(x -> q(x), 0..10)\n3-element Vector{IntervalRootFinding.Root{Interval{Float64}}}:\n Root([0.999999, 1.00001], :unique)\n Root([1.99999, 2.00001], :unique)\n Root([2.99999, 3.00001], :unique)\nSimilarly:\njulia> ANewDsc(coeffs(q))\nThere were 3 isolating intervals found:\n[2.62…, 3.62…]₂₅₆\n[1.5…, 2.62…]₂₅₆\n[-0.50…, 1.5…]₂₅₆","category":"page"},{"location":"#Fitting-a-polynomial-to-arbitrary-data","page":"Home","title":"Fitting a polynomial to arbitrary data","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The fit function will fit a polynomial (of degree deg) to data x and y using polynomial interpolation or a (weighted) least-squares approximation.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Fit a polynomial (of degree deg or less) to x and y using a least-squares approximation.","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> xs = 0:4; ys = @. exp(-xs) + sin(xs);\n\njulia> p =  fit(xs, ys); map(x -> round(x, digits=4), p)\nPolynomial(1.0 + 0.0593*x + 0.3959*x^2 - 0.2846*x^3 + 0.0387*x^4)\n\njulia> p = fit(ChebyshevT, xs, ys, 2); map(x -> round(x, digits=4), p)\nChebyshevT(0.5413⋅T_0(x) - 0.8991⋅T_1(x) - 0.4238⋅T_2(x))","category":"page"},{"location":"","page":"Home","title":"Home","text":"This provides a visual example:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Plots, Polynomials\n\nxs = range(0, 10, length=10)\nys = @. exp(-xs)\n\nf = fit(xs, ys)     # degree = length(xs) - 1\nf2 = fit(xs, ys, 2) # degree = 2\n\nscatter(xs, ys, markerstrokewidth=0, label=\"Data\")\nplot!(f, extrema(xs)..., label=\"Interpolation\")\nplot!(f2, extrema(xs)..., label=\"Quadratic Fit\")\nsavefig(\"polyfit.svg\"); nothing # hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: )","category":"page"},{"location":"#Other-bases","page":"Home","title":"Other bases","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A polynomial, e.g. a_0 + a_1 x + a_2 x^2 + ... + a_n x^n, can be seen as a collection of coefficients, [a_0, a_1, ..., a_n], relative to some polynomial basis. The most  familiar basis being  the standard one: 1, x, x^2, ...  Alternative bases are possible.  The ChebyshevT polynomials are  implemented, as an example. The constructor is ChebyshevT, an exposed alias for MutableDensePolynomial{ChebyshevTBasis}.","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> p1 = ChebyshevT([1.0, 2.0, 3.0])\nChebyshevT(1.0⋅T_0(x) + 2.0⋅T_1(x) + 3.0⋅T_2(x))\n\njulia> p2 = ChebyshevT{Float64}([0, 1, 2])\nChebyshevT(1.0⋅T_1(x) + 2.0⋅T_2(x))\n\njulia> p1 + p2\nChebyshevT(1.0⋅T_0(x) + 3.0⋅T_1(x) + 5.0⋅T_2(x))\n\njulia> p1 * p2\nChebyshevT(4.0⋅T_0(x) + 4.5⋅T_1(x) + 3.0⋅T_2(x) + 3.5⋅T_3(x) + 3.0⋅T_4(x))\n\njulia> derivative(p1)\nChebyshevT(2.0⋅T_0(x) + 12.0⋅T_1(x))\n\njulia> integrate(p2)\nChebyshevT(- 1.0⋅T_1(x) + 0.25⋅T_2(x) + 0.3333333333333333⋅T_3(x))\n\njulia> convert(Polynomial, p1)\nPolynomial(-2.0 + 2.0*x + 6.0*x^2)\n\njulia> convert(ChebyshevT, Polynomial([1.0, 2,  3]))\nChebyshevT(2.5⋅T_0(x) + 2.0⋅T_1(x) + 1.5⋅T_2(x))","category":"page"},{"location":"#Iteration","page":"Home","title":"Iteration","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If its basis is implicit, then a polynomial may be  seen as just a vector of  coefficients. Vectors are 1-based, but, for convenience, most polynomial types are naturally 0-based, for purposes of indexing (e.g. getindex, setindex!, eachindex). Iteration over a polynomial steps through the underlying coefficients.","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> as = [1,2,3,4,5]; p = Polynomial(as);\n\njulia> as[3], p[2], collect(p)[3]\n(3, 3, 3)","category":"page"},{"location":"","page":"Home","title":"Home","text":"The pairs iterator, iterates over the indices and coefficients, attempting to match how pairs applies to the underlying storage model:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> v = [1,2,0,4]\n4-element Vector{Int64}:\n 1\n 2\n 0\n 4\n\njulia> p,ip,sp,lp = Polynomial(v), ImmutablePolynomial(v), SparsePolynomial(v), LaurentPolynomial(v, -1);\n\njulia> collect(pairs(p))\n4-element Vector{Pair{Int64, Int64}}:\n 0 => 1\n 1 => 2\n 2 => 0\n 3 => 4\n\njulia> collect(pairs(ip)) == collect(pairs(p))\ntrue\n\njulia> collect(pairs(sp)) # unordered dictionary with only non-zero terms\n3-element Vector{Pair{Int64, Int64}}:\n 0 => 1\n 3 => 4\n 1 => 2\n\njulia> collect(pairs(lp))\n4-element Vector{Pair{Int64, Int64}}:\n -1 => 1\n  0 => 2\n  1 => 0\n  2 => 4","category":"page"},{"location":"","page":"Home","title":"Home","text":"The unexported monomials iterator iterates over the terms (p[i]*Polynomials.basis(p,i)) of the polynomial:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> p = Polynomial([1,2,0,4], :u)\nPolynomial(1 + 2*u + 4*u^3)\n\njulia> collect(Polynomials.monomials(p))\n4-element Vector{Any}:\n Polynomial(1)\n Polynomial(2*u)\n Polynomial(0)\n Polynomial(4*u^3)","category":"page"},{"location":"","page":"Home","title":"Home","text":"The map function for polynomials is idiosyncratic, as iteration over polynomials is over the vector of coefficients, but map will also maintain the type of the polynomial. Here we use map to smooth out the round-off error coming from the root-finding algorithm used internally when converting to the FactoredPolynomial type:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> p = Polynomial([24, -50, 35, -10, 1])\nPolynomial(24 - 50*x + 35*x^2 - 10*x^3 + x^4)\n\njulia> q = convert(FactoredPolynomial, p) # noisy form of `factor`:\nFactoredPolynomial((x - 4.0000000000000036) * (x - 1.0000000000000002) * (x - 2.9999999999999942) * (x - 2.0000000000000018))\n\njulia> map(x -> round(x, digits=10), q)\nFactoredPolynomial((x - 4.0) * (x - 2.0) * (x - 3.0) * (x - 1.0))","category":"page"},{"location":"#The-element-type","page":"Home","title":"The element type","text":"","category":"section"},{"location":"#Relationship-between-the-T-and-P{T,X}","page":"Home","title":"Relationship between the T and P{T,X}","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The addition of a polynomial and a scalar, such as","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using Polynomials\n\njulia> p = Polynomial([1,2,3], :x)\nPolynomial(1 + 2*x + 3*x^2)\n\njulia> p + 3\nPolynomial(4 + 2*x + 3*x^2)","category":"page"},{"location":"","page":"Home","title":"Home","text":"seems natural, but in Julia, as 3 is of type Int and p of type Polynomial{Int,:x} some addition must be defined. The basic idea  is that 3 is promoted to the constant polynomial 3 with indeterminate :x as 3*one(p) and then addition of p + 3*one(p) is performed.","category":"page"},{"location":"","page":"Home","title":"Home","text":"This identification of a scalar with a constant polynomial can go both ways. If q is a constant polynomial of type Polynomial{Int, :y} then we should expect that p+q would be defined, as p plus the constant term of q. Indeed this is the case","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> q = Polynomial(3, :y)\nPolynomial(3)\n\njulia> p + q\nPolynomial(4 + 2*x + 3*x^2)","category":"page"},{"location":"","page":"Home","title":"Home","text":"If q is non-constant, such as variable(Polynomial, :y), then there would be an error due to the mismatched symbols. (The mathematical result would need a multivariate polynomial, not a univariate polynomial, as this package provides.)","category":"page"},{"location":"","page":"Home","title":"Home","text":"The same conversion is done for polynomial multiplication: constant polynomials are treated as numbers; non-constant polynomials must have their symbols match.","category":"page"},{"location":"","page":"Home","title":"Home","text":"There is an oddity – though the following two computations look the same, they are technically different:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> one(Polynomial, :x) + one(Polynomial, :y)\nPolynomial(2.0)\n\njulia> one(Polynomial, :y) + one(Polynomial, :x)\nPolynomial(2.0)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Both are constant polynomials over Int, but the first has the indeterminate :y, the second :x.","category":"page"},{"location":"","page":"Home","title":"Home","text":"This technical difference causes no issues with polynomial addition or multiplication, as there constant polynomials are treated as numbers, but can be an issue when constant polynomials are used as array elements.","category":"page"},{"location":"","page":"Home","title":"Home","text":"For arrays, the promotion of numbers to polynomials, allows natural constructions like:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> p = Polynomial([1,2],:x)\nPolynomial(1 + 2*x)\n\njulia> q = Polynomial([1,2],:y)  # non-constant polynomials with different indeterminates\nPolynomial(1 + 2*y)\n\njulia> [1 p]\n1×2 Matrix{Polynomial{Int64, :x}}:\n Polynomial(1)  Polynomial(1 + 2*x)\n\njulia> [1 one(q)]\n1×2 Matrix{Polynomial{Int64, :y}}:\n Polynomial(1)  Polynomial(1)","category":"page"},{"location":"","page":"Home","title":"Home","text":"However, as there would be an ambiguous outcome of the following","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> [one(p) one(q)]\nERROR: ArgumentError: Polynomials have different indeterminates\n[...]","category":"page"},{"location":"","page":"Home","title":"Home","text":"an error is thrown.","category":"page"},{"location":"","page":"Home","title":"Home","text":"In general, arrays with mixtures of non-constant polynomials with different indeterminates will error. By default, an error will occur when constant polynomials with different indeterminates are used as components. However, for typed arrays, conversion will allow such constructs to be used.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Using one(q) for a constant polynomial with indeterminate :y we have:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> P = typeof(p)\nPolynomial{Int64, :x} (alias for Polynomials.MutableDensePolynomial{Polynomials.StandardBasis, Int64, :x})\n\njulia> P[one(p) one(q)]\n1×2 Matrix{Polynomial{Int64, :x}}:\n Polynomial(1)  Polynomial(1)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Of course, by not being explicit, there are sill gotchas. For example, we can construct this matrix without a specific types:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> [one(p), one(q)+one(p)]\n2-element Vector{Polynomial{Int64, :x}}:\n Polynomial(1)\n Polynomial(2)","category":"page"},{"location":"","page":"Home","title":"Home","text":"but not this one:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> [one(p), one(p) + one(q)]\nERROR: ArgumentError: Polynomials have different indeterminates\n[...]","category":"page"},{"location":"","page":"Home","title":"Home","text":"Also, mixing types can result in unspecific symbols, as this example shows:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> [1 p; p 1] + [1 2one(q); 3 4] # array{P{T,:x}} + array{P{T,:y}}\n2×2 Matrix{Polynomial{Int64}}:\n Polynomial(2)        Polynomial(3 + 2*x)\n Polynomial(4 + 2*x)  Polynomial(5)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Though were a non-constant polynomial with indeterminate y replacing 2one(q) above, that addition would throw an error.","category":"page"},{"location":"#Non-number-types-for-T","page":"Home","title":"Non-number types for T","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The coefficients of the polynomial may be non-number types, such as matrices or other polynomials, albeit not every operation is fully supported.","category":"page"},{"location":"","page":"Home","title":"Home","text":"For example, a polynomial with matrix coefficients, might be constructed with:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using Polynomials\n\njulia> a,b,c = [1 0;2 1], [1 0; 3 1], [1 0; 4 1]\n([1 0; 2 1], [1 0; 3 1], [1 0; 4 1])\n\njulia> p = Polynomial([a,b,c])\nPolynomial([1 0; 2 1] + [1 0; 3 1]*x + [1 0; 4 1]*x^2)\n\njulia> q = derivative(p)\nPolynomial([1 0; 3 1] + [2 0; 8 2]*x)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Various operations are available, derivative was shown above, here are the vector-space operations:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> 2p\nPolynomial([2 0; 4 2] + [2 0; 6 2]*x + [2 0; 8 2]*x^2)\n\njulia> p + q\nPolynomial([2 0; 5 2] + [3 0; 11 3]*x + [1 0; 4 1]*x^2)","category":"page"},{"location":"","page":"Home","title":"Home","text":"polynomial multiplication:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> p * q\nPolynomial([1 0; 5 1] + [3 0; 18 3]*x + [3 0; 21 3]*x^2 + [2 0; 16 2]*x^3)","category":"page"},{"location":"","page":"Home","title":"Home","text":"polynomial evaluation, here either with a scalar or a matrix:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> p(2)\n2×2 Matrix{Int64}:\n  7  0\n 24  7\n\njulia> p(b)\n2×2 Matrix{Int64}:\n  3  0\n 18  3","category":"page"},{"location":"","page":"Home","title":"Home","text":"But if the type T lacks support of some generic functions, such as zero(T) and one(T), then there may be issues. For example,  when T <: AbstractMatrix the output of p[degree(p)+1] is an error, as the implementation assumes zero(T) is defined. For static arrays, this isn't an issue, as there is support for zero(T). Other polynomial types, such as SparsePolynomial have less support, as some specialized methods assume more of the generic interface be implemented.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Similarly, using polynomials for T is a possibility:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> a,b,c = Polynomial([1],:y), Polynomial([0,1],:y), Polynomial([0,0,1],:y)\n(Polynomial(1), Polynomial(y), Polynomial(y^2))\n\njulia> p = Polynomial([a,b,c], :x)\nPolynomial(Polynomial(1) + Polynomial(y)*x + Polynomial(y^2)*x^2)\n\njulia> q = derivative(p)\nPolynomial(Polynomial(y) + Polynomial(2*y^2)*x)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Again, much works:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> 2p\nPolynomial(Polynomial(2) + Polynomial(2*y)*x + Polynomial(2*y^2)*x^2)\n\njulia> p + q\nPolynomial(Polynomial(1 + y) + Polynomial(y + 2*y^2)*x + Polynomial(y^2)*x^2)\n\njulia> p(2)\nPolynomial(1 + 2*y + 4*y^2)\n\njulia> p(b)\nPolynomial(1 + y^2 + y^4)","category":"page"},{"location":"","page":"Home","title":"Home","text":"But much doesn't. For example, implicit promotion can fail. For example, the scalar multiplication p * b will fail, as the methods assume this is the fallback polynomial multiplication and not the intended scalar multiplication.","category":"page"},{"location":"#Rational-functions","page":"Home","title":"Rational functions","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The package provides support for rational functions – fractions of polynomials (for most types). The construction of the basic type mirrors the construction of rational numbers.","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> P = FactoredPolynomial\nFactoredPolynomial\n\njulia> p,q = fromroots(P, [1,2,3,4]), fromroots(P, [2,2,3,5])\n(FactoredPolynomial((x - 4) * (x - 1) * (x - 3) * (x - 2)), FactoredPolynomial((x - 5) * (x - 2)² * (x - 3)))\n\njulia> pq = p // q\n((x - 4) * (x - 1) * (x - 3) * (x - 2)) // ((x - 5) * (x - 2)² * (x - 3))\n\njulia> lowest_terms(pq)\n((x - 4.0) * (x - 1.0)) // ((x - 5.0) * (x - 2.0))\n\njulia> d,r = residues(pq); r\nDict{Float64, Vector{Float64}} with 2 entries:\n  5.0 => [1.33333]\n  2.0 => [0.666667]\n\njulia> x = variable(p);\n\njulia> for (λ, rs) ∈ r # reconstruct p/q from output of `residues`\n           for (i,rᵢ) ∈ enumerate(rs)\n               d += rᵢ//(x-λ)^i\n           end\n       end\n\njulia> d\n((x - 1.0000000000000002) * (x - 4.0)) // ((x - 5.0) * (x - 2.0))","category":"page"},{"location":"","page":"Home","title":"Home","text":"A basic plot recipe is provided.","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Plots, Polynomials\nP = FactoredPolynomial\np,q = fromroots(P, [1,2,3]), fromroots(P, [2,3,3,0])\nplot(p//q)\nsavefig(\"rational_function.svg\"); nothing # hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: )","category":"page"},{"location":"#Related-Packages","page":"Home","title":"Related Packages","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"StaticUnivariatePolynomials.jl Fixed-size univariate polynomials backed by a Tuple\nMultiPoly.jl for sparse multivariate polynomials\nDynamicPolynomials.jl Multivariate polynomials implementation of commutative and non-commutative variables\nMultivariatePolynomials.jl for multivariate polynomials and moments of commutative or non-commutative variables\nPolynomialRings.jl A library for arithmetic and algebra with multi-variable polynomials.\nAbstractAlgebra.jl, Nemo.jl for generic polynomial rings, matrix spaces, fraction fields, residue rings, power series, Hecke.jl for algebraic number theory.\nLaurentPolynomials.jl A package for Laurent polynomials.\nCommutativeAlgebra.jl the start of a computer algebra system specialized to discrete calculations with support for polynomials.\nPolynomialRoots.jl for a fast complex polynomial root finder. For larger degree problems, also FastPolynomialRoots and AMRVW.\nSpecialPolynomials.jl A package providing various polynomial types beyond the standard basis polynomials in Polynomials.jl. Includes interpolating polynomials, Bernstein polynomials, and classical orthogonal polynomials.\nClassicalOrthogonalPolynomials.jl A Julia package for classical orthogonal polynomials and expansions. Includes chebyshevt, chebyshevu, legendrep, jacobip, ultrasphericalc, hermiteh, and laguerrel. The same repository includes FastGaussQuadrature.jl, FastTransforms.jl, and the ApproxFun packages.","category":"page"},{"location":"#Contributing","page":"Home","title":"Contributing","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you are interested in this project, feel free to open an issue or pull request! In general, any changes must be thoroughly tested, allow deprecation, and not deviate too far from the common interface. All PR's must have an updated project version, as well, to keep the continuous delivery cycle up-to-date.","category":"page"},{"location":"polynomials/chebyshev/#Chebyshev-Polynomials","page":"Chebyshev","title":"Chebyshev Polynomials","text":"","category":"section"},{"location":"polynomials/chebyshev/","page":"Chebyshev","title":"Chebyshev","text":"The Chebyshev polynomials are two sequences of polynomials, T_n and U_n. The Chebyshev polynomials of the first kind, T_n, can be defined by the recurrence relation:","category":"page"},{"location":"polynomials/chebyshev/","page":"Chebyshev","title":"Chebyshev","text":"T_0(x)=1 T_1(x)=x","category":"page"},{"location":"polynomials/chebyshev/","page":"Chebyshev","title":"Chebyshev","text":"T_n+1(x) = 2xT_n(x)-T_n-1(x)","category":"page"},{"location":"polynomials/chebyshev/","page":"Chebyshev","title":"Chebyshev","text":"The Chebyshev polynomioals of the second kind, U_n(x), can be defined by","category":"page"},{"location":"polynomials/chebyshev/","page":"Chebyshev","title":"Chebyshev","text":"U_0(x)=1 U_1(x)=2x","category":"page"},{"location":"polynomials/chebyshev/","page":"Chebyshev","title":"Chebyshev","text":"U_n+1(x) = 2xU_n(x) - U_n-1(x)","category":"page"},{"location":"polynomials/chebyshev/","page":"Chebyshev","title":"Chebyshev","text":"Both T_n and U_n have degree n, and any polynomial of degree n may be uniquely written as a linear combination of the polynomials T_0, T_1, ..., T_n (similarly with U_n).","category":"page"},{"location":"polynomials/chebyshev/#First-Kind","page":"Chebyshev","title":"First Kind","text":"","category":"section"},{"location":"polynomials/chebyshev/#Polynomials.ChebyshevT","page":"Chebyshev","title":"Polynomials.ChebyshevT","text":"ChebyshevT{T, X}(coeffs::AbstractVector)\n\nChebyshev polynomial of the first kind.\n\nConstruct a polynomial from its coefficients coeffs, lowest order first, optionally in terms of the given variable var, which can be a character, symbol, or string.\n\nnote: Note\nChebyshevT is not axis-aware, and it treats coeffs simply as a list of coefficients with the first index always corresponding to the coefficient of T_0(x).\n\nExamples\n\njulia> using Polynomials\n\njulia> p = ChebyshevT([1, 0, 3, 4])\nChebyshevT(1⋅T_0(x) + 3⋅T_2(x) + 4⋅T_3(x))\n\njulia> ChebyshevT([1, 2, 3, 0], :s)\nChebyshevT(1⋅T_0(s) + 2⋅T_1(s) + 3⋅T_2(s))\n\njulia> one(ChebyshevT)\nChebyshevT(1.0⋅T_0(x))\n\njulia> p(0.5)\n-4.5\n\njulia> Polynomials.evalpoly(5.0, p, false) # bypasses the domain check done in p(5.0)\n2088.0\n\nThe latter shows how to evaluate a ChebyshevT polynomial outside of its domain, which is [-1,1]. (For newer versions of Julia, evalpoly is an exported function from Base with methods extended in this package, so the module qualification is unnecessary.\n\nnote: Note\nThe Chebyshev polynomials are also implemented in ApproxFun, ClassicalOrthogonalPolynomials.jl, FastTransforms.jl, and SpecialPolynomials.jl.\n\n\n\n\n\n","category":"type"},{"location":"polynomials/chebyshev/","page":"Chebyshev","title":"Chebyshev","text":"The ChebyshevT type holds coefficients representing the polynomial a_0 T_0 + a_1 T_1 +  + a_n T_n.","category":"page"},{"location":"polynomials/chebyshev/","page":"Chebyshev","title":"Chebyshev","text":"For example, the basis polynomial T_4 can be represented with ChebyshevT([0,0,0,0,1]).","category":"page"},{"location":"polynomials/chebyshev/#Conversion","page":"Chebyshev","title":"Conversion","text":"","category":"section"},{"location":"polynomials/chebyshev/","page":"Chebyshev","title":"Chebyshev","text":"ChebyshevT can be converted to Polynomial and vice-versa.","category":"page"},{"location":"polynomials/chebyshev/","page":"Chebyshev","title":"Chebyshev","text":"julia> c = ChebyshevT([1, 0, 3, 4])\nChebyshevT(1⋅T_0(x) + 3⋅T_2(x) + 4⋅T_3(x))\n\njulia> p = convert(Polynomial, c)\nPolynomial(-2.0 - 12.0*x + 6.0*x^2 + 16.0*x^3)\n\njulia> convert(ChebyshevT, p)\nChebyshevT(1.0⋅T_0(x) + 3.0⋅T_2(x) + 4.0⋅T_3(x))","category":"page"},{"location":"extensions/#Extensions","page":"Extensions","title":"Extensions","text":"","category":"section"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"As of v1.9 of Julia, packages can provide extension code which is loaded when external packages are loaded.","category":"page"},{"location":"extensions/#Makie","page":"Extensions","title":"Makie","text":"","category":"section"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"When Makie is loaded, a plot recipe is provided.","category":"page"},{"location":"extensions/#ChainRulesCore","page":"Extensions","title":"ChainRulesCore","text":"","category":"section"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"When ChainRulesCore is loaded, a frule and rrule is defined for to integrate with different autodifferentiation packages.","category":"page"},{"location":"extensions/#MutableArithmetics","page":"Extensions","title":"MutableArithmetics","text":"","category":"section"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"When the MutableArithmetics package is loaded, an extension provides its functionality for a few polynomial types, described in the following. Prior to v1.9 the external package PolynomialsMutableArithmetics provided the same functionality.","category":"page"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"While polynomials of type Polynomial are mutable objects, operations such as +, -, *, always create new polynomials without modifying its arguments. The time needed for these allocations and copies of the polynomial coefficients may be noticeable in some use cases. This is amplified when the coefficients are for instance BigInt or BigFloat which are mutable themselves. This can be avoided by modifying existing polynomials to contain the result of the operation using the MutableArithmetics (MA) API.","category":"page"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"Consider for instance the following arrays of polynomials","category":"page"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"using Polynomials\nd, m, n = 30, 20, 20\np(d) = Polynomial(big.(1:d))\nA = [p(d) for i in 1:m, j in 1:n]\nb = [p(d) for i in 1:n]","category":"page"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"In this case, the arrays are mutable objects for which the elements are mutable polynomials which have mutable coefficients (BigInts). These three nested levels of mutable objects communicate with the MA API in order to reduce allocation. Calling A * b requires approximately 40 MiB due to 2 M allocations as it does not exploit any mutability.","category":"page"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"using MutableArithmetics  # or `using PolynomialsMutableArithmetics` to register `Polynomials` with `MutableArithmetics`\n\nconst MA = MutableArithmetics\nMA.operate(*, A, b)","category":"page"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"exploits the mutability and hence only allocates approximately 70 KiB due to 4 k allocations.","category":"page"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"If the resulting vector is already allocated, e.g.,","category":"page"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"z(d) = Polynomial([zero(BigInt) for i in 1:d])\nc = [z(2d - 1) for i in 1:m]","category":"page"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"then we can exploit its mutability with","category":"page"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"MA.operate!(MA.add_mul, c, A, b)","category":"page"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"to reduce the allocation down to 48 bytes due to 3 allocations.","category":"page"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"These remaining allocations are due to the BigInt buffer used to store the result of intermediate multiplications. This buffer can be preallocated with:","category":"page"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"buffer = MA.buffer_for(MA.add_mul, typeof(c), typeof(A), typeof(b))\nMA.buffered_operate!(buffer, MA.add_mul, c, A, b)","category":"page"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"then the second line is allocation-free.","category":"page"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"The MA.@rewrite macro rewrite an expression into an equivalent code that exploit the mutability of the intermediate results. For instance","category":"page"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"MA.@rewrite(A1 * b1 + A2 * b2)","category":"page"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"is rewritten into","category":"page"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"c = MA.operate!(MA.add_mul, MA.Zero(), A1, b1)\nMA.operate!(MA.add_mul, c, A2, b2)","category":"page"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"which is equivalent to","category":"page"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"c = MA.operate(*, A1, b1)\nMA.mutable_operate!(MA.add_mul, c, A2, b2)","category":"page"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"note: Note\nNote that currently, only the Polynomial and Polynomials.PnPolynomial types implement the API and  only","category":"page"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"part of it is implemented","category":"page"},{"location":"extensions/#PolyCompat","page":"Extensions","title":"PolyCompat","text":"","category":"section"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"While not an extension, the older  Poly type that this package used prior to v0.7  is implemented as an alternate basis and provided on an opt-in bases by executing using Polynomials.PolyCompat. This is to provide support for older code bases.","category":"page"}]
}
